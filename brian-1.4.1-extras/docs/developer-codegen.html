<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Code generation &mdash; Brian 1.4.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.4.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Brian 1.4.1 documentation" href="index.html" />
    <link rel="up" title="Developer’s guide" href="developer.html" />
    <link rel="next" title="Brian package structure" href="developer-packagestructure.html" />
    <link rel="prev" title="Equations" href="developer-equations.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="developer-packagestructure.html" title="Brian package structure"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="developer-equations.html" title="Equations"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Brian 1.4.1 documentation</a> &raquo;</li>
          <li><a href="developer.html" accesskey="U">Developer&#8217;s guide</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="code-generation">
<span id="index-0"></span><h1>Code generation<a class="headerlink" href="#code-generation" title="Permalink to this headline">¶</a></h1>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This section is a work in progress, documenting the most recent code generation
framework, which is in the package <tt class="docutils literal"><span class="pre">brian.experimental.codegen2</span></tt>.</p>
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>To generate code, we start with a basic statement or set of statements we want
to evaluate for all neurons, or for all synapses, and then apply various
transformations to generate code that will do this. We start from a
structured, language-invariant representation of the set of basic statements.
We then &#8216;resolve&#8217; the unknown symbols in it. This is done recursively, the
resolution of each symbol can add vectorised statements or loops to the
current representation, and add data to a namespace that will be associated to
the final code. Symbols will be things like a <a class="reference internal" href="reference-models-and-groups.html#brian.NeuronGroup" title="brian.NeuronGroup"><tt class="xref py py-class docutils literal"><span class="pre">NeuronGroup</span></tt></a> state
variable, or a synaptic weight value. The output of this process is a new,
more complicated structured representation, including things like loops if
necessary. Next, we convert this structured representation into a code
string. Finally, this code string is JIT-compiled into an executable object.</p>
<div class="section" id="using-numerical-integration-generation">
<h3>Using numerical integration generation<a class="headerlink" href="#using-numerical-integration-generation" title="Permalink to this headline">¶</a></h3>
<p>You can use Brian&#8217;s equations format to generate C/C++ code for a numerical
integration step, for example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">eqs</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">dv/dt = (ge+gi-(v+49*mV))/(20*ms) : volt</span>
<span class="s">dge/dt = -ge/(5*ms) : volt</span>
<span class="s">dgi/dt = -gi/(10*ms) : volt</span>
<span class="s">&#39;&#39;&#39;</span>
<span class="n">code</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">make_c_integrator</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">euler</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.1</span><span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="k">print</span> <span class="n">code</span>
</pre></div>
</div>
<p>has output:</p>
<div class="highlight-python"><pre>double _temp_v = 50.0*ge + 50.0*gi - 50.0*v - 2.45;
double _temp_ge = -200.0*ge;
double _temp_gi = -100.0*gi;
v += _temp_v*0.0001;
ge += _temp_ge*0.0001;
gi += _temp_gi*0.0001;</pre>
</div>
<p>See the documentation for the function <a class="reference internal" href="#brian.experimental.codegen2.make_c_integrator" title="brian.experimental.codegen2.make_c_integrator"><tt class="xref py py-func docutils literal"><span class="pre">make_c_integrator()</span></tt></a>.</p>
</div>
<div class="section" id="using-the-code-generation-package">
<h3>Using the code generation package<a class="headerlink" href="#using-the-code-generation-package" title="Permalink to this headline">¶</a></h3>
<p>The basic way to use the code generation module is as follows:</p>
<ol class="arabic simple">
<li>Create a <a class="reference internal" href="#brian.experimental.codegen2.Block" title="brian.experimental.codegen2.Block"><tt class="xref py py-class docutils literal"><span class="pre">Block</span></tt></a> of <a class="reference internal" href="#brian.experimental.codegen2.Statement" title="brian.experimental.codegen2.Statement"><tt class="xref py py-class docutils literal"><span class="pre">Statement</span></tt></a> objects which you want to
execute. You can use <a class="reference internal" href="#brian.experimental.codegen2.statements_from_codestring" title="brian.experimental.codegen2.statements_from_codestring"><tt class="xref py py-func docutils literal"><span class="pre">statements_from_codestring()</span></tt></a> to do this.</li>
<li>Create a dictionary of <a class="reference internal" href="#brian.experimental.codegen2.Symbol" title="brian.experimental.codegen2.Symbol"><tt class="xref py py-class docutils literal"><span class="pre">Symbol</span></tt></a> objects corresponding to the symbols
in the block above.</li>
<li>Call <a class="reference internal" href="#brian.experimental.codegen2.CodeItem.generate" title="brian.experimental.codegen2.CodeItem.generate"><tt class="xref py py-meth docutils literal"><span class="pre">CodeItem.generate()</span></tt></a> with the specified language and symbols, to
give you a <a class="reference internal" href="#brian.experimental.codegen2.Code" title="brian.experimental.codegen2.Code"><tt class="xref py py-class docutils literal"><span class="pre">Code</span></tt></a> object.</li>
<li>Optionally, insert additional data into the namespace of the <a class="reference internal" href="#brian.experimental.codegen2.Code" title="brian.experimental.codegen2.Code"><tt class="xref py py-class docutils literal"><span class="pre">Code</span></tt></a>
object.</li>
<li>Use the <a class="reference internal" href="#brian.experimental.codegen2.Code" title="brian.experimental.codegen2.Code"><tt class="xref py py-class docutils literal"><span class="pre">Code</span></tt></a> object via <tt class="docutils literal"><span class="pre">code(name1=val1,</span> <span class="pre">name2=val2)</span></tt> where the
<tt class="docutils literal"><span class="pre">name=val</span></tt> are to be inserted into the namespace before the code is called.</li>
</ol>
<p>This process is very clearly illustrated in the source code for
<a class="reference internal" href="#brian.experimental.codegen2.CodeGenStateUpdater" title="brian.experimental.codegen2.CodeGenStateUpdater"><tt class="xref py py-class docutils literal"><span class="pre">CodeGenStateUpdater</span></tt></a>.</p>
</div>
<div class="section" id="structure-of-the-package">
<h3>Structure of the package<a class="headerlink" href="#structure-of-the-package" title="Permalink to this headline">¶</a></h3>
<p>The following are the main elements of the code generation package:</p>
<dl class="docutils">
<dt><a class="reference internal" href="#brian.experimental.codegen2.Code" title="brian.experimental.codegen2.Code"><tt class="xref py py-class docutils literal"><span class="pre">Code</span></tt></a></dt>
<dd>This is the output of the code generation package, a compilable/compiled
code fragment, along with a namespace in which it is executed.</dd>
<dt><a class="reference internal" href="#brian.experimental.codegen2.Language" title="brian.experimental.codegen2.Language"><tt class="xref py py-class docutils literal"><span class="pre">Language</span></tt></a></dt>
<dd>Used to specify which language the output should have.</dd>
<dt><a class="reference internal" href="#brian.experimental.codegen2.CodeItem" title="brian.experimental.codegen2.CodeItem"><tt class="xref py py-class docutils literal"><span class="pre">CodeItem</span></tt></a></dt>
<dd>Before code is converted into a specific language, it is stored in a
language-invariant format consisting of <a class="reference internal" href="#brian.experimental.codegen2.CodeItem" title="brian.experimental.codegen2.CodeItem"><tt class="xref py py-class docutils literal"><span class="pre">CodeItem</span></tt></a> objects, which
can in turn contain other <a class="reference internal" href="#brian.experimental.codegen2.CodeItem" title="brian.experimental.codegen2.CodeItem"><tt class="xref py py-class docutils literal"><span class="pre">CodeItem</span></tt></a> objects. The main derived
classes from this are <a class="reference internal" href="#brian.experimental.codegen2.Block" title="brian.experimental.codegen2.Block"><tt class="xref py py-class docutils literal"><span class="pre">Block</span></tt></a> and <a class="reference internal" href="#brian.experimental.codegen2.Statement" title="brian.experimental.codegen2.Statement"><tt class="xref py py-class docutils literal"><span class="pre">Statement</span></tt></a>. The first can
contain a series of statements, or it can be a for loop, an if block, etc.
A <a class="reference internal" href="#brian.experimental.codegen2.Statement" title="brian.experimental.codegen2.Statement"><tt class="xref py py-class docutils literal"><span class="pre">Statement</span></tt></a> can be a <a class="reference internal" href="#brian.experimental.codegen2.MathematicalStatement" title="brian.experimental.codegen2.MathematicalStatement"><tt class="xref py py-class docutils literal"><span class="pre">MathematicalStatement</span></tt></a> or
<a class="reference internal" href="#brian.experimental.codegen2.CodeStatement" title="brian.experimental.codegen2.CodeStatement"><tt class="xref py py-class docutils literal"><span class="pre">CodeStatement</span></tt></a>. The former is for things like <tt class="docutils literal"><span class="pre">x=y*z</span></tt> and the
latter for things like <tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">arr[index]</span></tt>.</dd>
<dt><a class="reference internal" href="#brian.experimental.codegen2.Symbol" title="brian.experimental.codegen2.Symbol"><tt class="xref py py-class docutils literal"><span class="pre">Symbol</span></tt></a>, <a class="reference internal" href="#brian.experimental.codegen2.resolve" title="brian.experimental.codegen2.resolve"><tt class="xref py py-func docutils literal"><span class="pre">resolve()</span></tt></a></dt>
<dd>A <a class="reference internal" href="#brian.experimental.codegen2.CodeItem" title="brian.experimental.codegen2.CodeItem"><tt class="xref py py-class docutils literal"><span class="pre">CodeItem</span></tt></a> with unresolved dependencies needs to be resolved by
the function <a class="reference internal" href="#brian.experimental.codegen2.resolve" title="brian.experimental.codegen2.resolve"><tt class="xref py py-func docutils literal"><span class="pre">resolve()</span></tt></a>. Each unresolved depdendency should correspond
to a <a class="reference internal" href="#brian.experimental.codegen2.Symbol" title="brian.experimental.codegen2.Symbol"><tt class="xref py py-class docutils literal"><span class="pre">Symbol</span></tt></a> which knows how to modify a <a class="reference internal" href="#brian.experimental.codegen2.CodeItem" title="brian.experimental.codegen2.CodeItem"><tt class="xref py py-class docutils literal"><span class="pre">CodeItem</span></tt></a> in order
to resolve itself. For example, a <a class="reference internal" href="#brian.experimental.codegen2.NeuronGroupStateVariableSymbol" title="brian.experimental.codegen2.NeuronGroupStateVariableSymbol"><tt class="xref py py-class docutils literal"><span class="pre">NeuronGroupStateVariableSymbol</span></tt></a>
will insert the <a class="reference internal" href="reference-models-and-groups.html#brian.NeuronGroup" title="brian.NeuronGroup"><tt class="xref py py-class docutils literal"><span class="pre">NeuronGroup</span></tt></a> state variable value into the
namespace, create a new array symbol like <tt class="docutils literal"><span class="pre">__arr_V</span></tt> for symbol <tt class="docutils literal"><span class="pre">V</span></tt>,
and resolve itself either by doing nothing (in Python, as the variable is
already vectorised), or by introducing a loop (in C++), or by setting the
index variable as the kernel thread (for GPU). For more details, see
the section on resolution below.</dd>
<dt><a class="reference internal" href="#brian.experimental.codegen2.make_integration_step" title="brian.experimental.codegen2.make_integration_step"><tt class="xref py py-func docutils literal"><span class="pre">make_integration_step()</span></tt></a>, <a class="reference internal" href="#brian.experimental.codegen2.euler" title="brian.experimental.codegen2.euler"><tt class="xref py py-func docutils literal"><span class="pre">euler()</span></tt></a>, <a class="reference internal" href="#brian.experimental.codegen2.rk2" title="brian.experimental.codegen2.rk2"><tt class="xref py py-func docutils literal"><span class="pre">rk2()</span></tt></a>, <a class="reference internal" href="#brian.experimental.codegen2.exp_euler" title="brian.experimental.codegen2.exp_euler"><tt class="xref py py-func docutils literal"><span class="pre">exp_euler()</span></tt></a></dt>
<dd>Numerical integration schemes, each integration scheme (such as
<a class="reference internal" href="#brian.experimental.codegen2.euler" title="brian.experimental.codegen2.euler"><tt class="xref py py-func docutils literal"><span class="pre">euler()</span></tt></a>) converts a set of differential equations into a sequence of
<a class="reference internal" href="#brian.experimental.codegen2.MathematicalStatement" title="brian.experimental.codegen2.MathematicalStatement"><tt class="xref py py-class docutils literal"><span class="pre">MathematicalStatement</span></tt></a> objects comprising an integration step.</dd>
<dt><a class="reference internal" href="#brian.experimental.codegen2.CodeGenStateUpdater" title="brian.experimental.codegen2.CodeGenStateUpdater"><tt class="xref py py-class docutils literal"><span class="pre">CodeGenStateUpdater</span></tt></a>, <a class="reference internal" href="#brian.experimental.codegen2.CodeGenThreshold" title="brian.experimental.codegen2.CodeGenThreshold"><tt class="xref py py-class docutils literal"><span class="pre">CodeGenThreshold</span></tt></a>, <a class="reference internal" href="#brian.experimental.codegen2.CodeGenReset" title="brian.experimental.codegen2.CodeGenReset"><tt class="xref py py-class docutils literal"><span class="pre">CodeGenReset</span></tt></a>, <a class="reference internal" href="#brian.experimental.codegen2.CodeGenConnection" title="brian.experimental.codegen2.CodeGenConnection"><tt class="xref py py-class docutils literal"><span class="pre">CodeGenConnection</span></tt></a></dt>
<dd>Brian objects using code generation.</dd>
</dl>
</div>
</div>
<div class="section" id="resolution-process">
<h2>Resolution process<a class="headerlink" href="#resolution-process" title="Permalink to this headline">¶</a></h2>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>We start with a worked example. Consider the statement:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">V</span></tt> is a <tt class="xref py py-class docutils literal"><span class="pre">NeuronGroup</span></tt> state variable. We wish to transform this
into code that can be executed. In the case of Python, the output would look
like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">_neuron_index</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">_arr_V</span><span class="p">[</span><span class="n">_neuron_index</span><span class="p">]</span>
<span class="n">_arr_V</span><span class="p">[</span><span class="n">_neuron_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">V</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
<p>The symbol <tt class="docutils literal"><span class="pre">_arr_V</span></tt> would be added directly to the namespace.</p>
<p>In the case of C++ it would look like:</p>
<div class="highlight-python"><pre>for(int _neuron_index=0; _neuron_index&lt;_len__arr_V; _neuron_index++)
{
        double &amp;V = _arr_V[_neuron_index];
        V = V+1;
}</pre>
</div>
<p>Here the symbols <tt class="docutils literal"><span class="pre">_arr_V</span></tt> and <cite>_len__arr_V`</cite> would be added to the namespace.
The reason for these complicated names is to do with making the code as
generic as possible, not introducing namespace clashes (symbols starting with
<tt class="docutils literal"><span class="pre">_</span></tt> are reserved), etc.</p>
<p>The way the process works is we start with the statement <tt class="docutils literal"><span class="pre">V=V+1</span></tt> and a
<a class="reference internal" href="#brian.experimental.codegen2.Symbol" title="brian.experimental.codegen2.Symbol"><tt class="xref py py-class docutils literal"><span class="pre">Symbol</span></tt></a> object with name <tt class="docutils literal"><span class="pre">V</span></tt>, specifically a
<a class="reference internal" href="#brian.experimental.codegen2.NeuronGroupStateVariableSymbol" title="brian.experimental.codegen2.NeuronGroupStateVariableSymbol"><tt class="xref py py-class docutils literal"><span class="pre">NeuronGroupStateVariableSymbol</span></tt></a>. The statement <tt class="docutils literal"><span class="pre">V=V+1</span></tt> depends on
<tt class="docutils literal"><span class="pre">V</span></tt> with both a <a class="reference internal" href="#brian.experimental.codegen2.Read" title="brian.experimental.codegen2.Read"><tt class="xref py py-class docutils literal"><span class="pre">Read</span></tt></a> and <a class="reference internal" href="#brian.experimental.codegen2.Write" title="brian.experimental.codegen2.Write"><tt class="xref py py-class docutils literal"><span class="pre">Write</span></tt></a> dependency. We therefore
have to &#8216;resolve&#8217; the symbol <tt class="docutils literal"><span class="pre">V</span></tt>. To do this we call the method
<tt class="xref py py-meth docutils literal"><span class="pre">resolve()</span></tt> on <tt class="docutils literal"><span class="pre">V</span></tt>.</p>
<p>In the case of Python, this gives us:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V</span> <span class="o">=</span> <span class="n">_arr_V</span><span class="p">[</span><span class="n">_neuron_index</span><span class="p">]</span>
<span class="n">_arr_V</span><span class="p">[</span><span class="n">_neuron_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">V</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
<p>It adds <tt class="docutils literal"><span class="pre">_arr_V</span></tt> to the namespace, and creates a dependency on
<tt class="docutils literal"><span class="pre">_neuron_index</span></tt>. The reason that <tt class="docutils literal"><span class="pre">V=V+1</span></tt> is translated to
<tt class="docutils literal"><span class="pre">_arr_V[_neuron_index]</span> <span class="pre">=</span> <span class="pre">V+1</span></tt> is that on the left hand side we have a write
variable, and on the right hand side we have a read variable. In Python, when
vectorising, we have no choice but to give the underlying array with its slice
when writing to an array. However, at this point the code generation framework
doesn&#8217;t know what <tt class="docutils literal"><span class="pre">_neuron_index</span></tt> will be, so it could be, for example, an
array of indices. In this case, suppose we did <tt class="docutils literal"><span class="pre">V*V</span></tt> it would be more
efficient to compute <tt class="docutils literal"><span class="pre">V=_arr_V[_neuron_index]</span></tt> and then compute <tt class="docutils literal"><span class="pre">V*V</span></tt> than
to compute <tt class="docutils literal"><span class="pre">_arr_V[_neuron_index]*_arr_V[_neuron_index]</span></tt>, and in the case
where <tt class="docutils literal"><span class="pre">_neuron_index=slice(None)</span></tt> it is no slower, so we always do this.</p>
<p>In the case of C++, the first resolution step gives us:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">double</span> <span class="o">&amp;</span><span class="n">V</span> <span class="o">=</span> <span class="n">_arr_V</span><span class="p">[</span><span class="n">_neuron_index</span><span class="p">];</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>For the second resolution step, we need to resolve <tt class="docutils literal"><span class="pre">_neuron_index</span></tt>, which
is a symbol of type <a class="reference internal" href="#brian.experimental.codegen2.SliceIndex" title="brian.experimental.codegen2.SliceIndex"><tt class="xref py py-class docutils literal"><span class="pre">SliceIndex</span></tt></a>, telling us that <tt class="docutils literal"><span class="pre">_neuron_index</span></tt>
varies over all neurons. Note that we could also have <tt class="docutils literal"><span class="pre">_neuron_index</span></tt> being
an <a class="reference internal" href="#brian.experimental.codegen2.ArrayIndex" title="brian.experimental.codegen2.ArrayIndex"><tt class="xref py py-class docutils literal"><span class="pre">ArrayIndex</span></tt></a>, for examples <tt class="docutils literal"><span class="pre">spikes</span></tt>, and then this could be used
for a reset operation (we would iterate only over those indices of neurons
which had spiked). Here though, we iterate over all neurons. In Python, calling
the <a class="reference internal" href="#brian.experimental.codegen2.ArrayIndex.resolve" title="brian.experimental.codegen2.ArrayIndex.resolve"><tt class="xref py py-meth docutils literal"><span class="pre">resolve()</span></tt></a> method of <tt class="docutils literal"><span class="pre">_neuron_index</span></tt> gives us:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">_neuron_index</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">_arr_V</span><span class="p">[</span><span class="n">_neuron_index</span><span class="p">]</span>
<span class="n">_arr_V</span><span class="p">[</span><span class="n">_neuron_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">V</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
<p>and in C++:</p>
<div class="highlight-python"><pre>for(int _neuron_index=0; _neuron_index&lt;_len__arr_V; _neuron_index++)
{
        double &amp;V = _arr_V[_neuron_index];
        V = V+1;
}</pre>
</div>
<p>In both cases, the <tt class="docutils literal"><span class="pre">_neuron_index</span></tt> symbol is resolved and the process is
complete.</p>
<p>Note that we have actually mixed two stages here, the stage of generating a
structured representation of the code using <a class="reference internal" href="#brian.experimental.codegen2.CodeItem" title="brian.experimental.codegen2.CodeItem"><tt class="xref py py-class docutils literal"><span class="pre">CodeItem</span></tt></a> objects, and the
stage of generating code strings using <a class="reference internal" href="#brian.experimental.codegen2.CodeItem.convert_to" title="brian.experimental.codegen2.CodeItem.convert_to"><tt class="xref py py-meth docutils literal"><span class="pre">CodeItem.convert_to()</span></tt></a>. In fact,
the converting of, for example, <tt class="docutils literal"><span class="pre">V</span></tt> to <tt class="docutils literal"><span class="pre">_arr_V[_neuron_index]</span></tt> only happens
at the second stage.</p>
</div>
<div class="section" id="resolve">
<h3><a class="reference internal" href="#brian.experimental.codegen2.resolve" title="brian.experimental.codegen2.resolve"><tt class="xref py py-func docutils literal"><span class="pre">resolve()</span></tt></a><a class="headerlink" href="#resolve" title="Permalink to this headline">¶</a></h3>
<p>The first stage, acting on the structured representation of nested
<a class="reference internal" href="#brian.experimental.codegen2.CodeItem" title="brian.experimental.codegen2.CodeItem"><tt class="xref py py-class docutils literal"><span class="pre">CodeItem</span></tt></a> objects is resolved using the function <a class="reference internal" href="#brian.experimental.codegen2.resolve" title="brian.experimental.codegen2.resolve"><tt class="xref py py-func docutils literal"><span class="pre">resolve()</span></tt></a>. This
calls <a class="reference internal" href="#brian.experimental.codegen2.Symbol.resolve" title="brian.experimental.codegen2.Symbol.resolve"><tt class="xref py py-meth docutils literal"><span class="pre">Symbol.resolve()</span></tt></a> for each of the symbols in turn. The resolution
order is determined by an optimal efficiency algorithm, see the reference
documentation for <a class="reference internal" href="#brian.experimental.codegen2.resolve" title="brian.experimental.codegen2.resolve"><tt class="xref py py-func docutils literal"><span class="pre">resolve()</span></tt></a> for the full algorithm description.</p>
<p><a class="reference internal" href="#brian.experimental.codegen2.Symbol.resolve" title="brian.experimental.codegen2.Symbol.resolve"><tt class="xref py py-meth docutils literal"><span class="pre">Symbol.resolve()</span></tt></a> can do an arbitrary transformation of the input
<a class="reference internal" href="#brian.experimental.codegen2.CodeItem" title="brian.experimental.codegen2.CodeItem"><tt class="xref py py-class docutils literal"><span class="pre">CodeItem</span></tt></a>, but typically it will either do something like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">load</span><span class="p">()</span>
<span class="n">item</span>
<span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>Or something like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>
        <span class="n">item</span>
</pre></div>
</div>
<p>See the reference documentation for <a class="reference internal" href="#brian.experimental.codegen2.Symbol.resolve" title="brian.experimental.codegen2.Symbol.resolve"><tt class="xref py py-meth docutils literal"><span class="pre">Symbol.resolve()</span></tt></a>, and the
documentation for the most important symbols:</p>
<ul class="simple">
<li><a class="reference internal" href="#brian.experimental.codegen2.SliceIndex" title="brian.experimental.codegen2.SliceIndex"><tt class="xref py py-class docutils literal"><span class="pre">SliceIndex</span></tt></a></li>
<li><a class="reference internal" href="#brian.experimental.codegen2.ArraySymbol" title="brian.experimental.codegen2.ArraySymbol"><tt class="xref py py-class docutils literal"><span class="pre">ArraySymbol</span></tt></a></li>
<li><a class="reference internal" href="#brian.experimental.codegen2.ArrayIndex" title="brian.experimental.codegen2.ArrayIndex"><tt class="xref py py-class docutils literal"><span class="pre">ArrayIndex</span></tt></a></li>
<li><a class="reference internal" href="#brian.experimental.codegen2.NeuronGroupStateVariableSymbol" title="brian.experimental.codegen2.NeuronGroupStateVariableSymbol"><tt class="xref py py-class docutils literal"><span class="pre">NeuronGroupStateVariableSymbol</span></tt></a></li>
</ul>
</div>
<div class="section" id="convert-to">
<h3><a class="reference internal" href="#brian.experimental.codegen2.CodeItem.convert_to" title="brian.experimental.codegen2.CodeItem.convert_to"><tt class="xref py py-meth docutils literal"><span class="pre">convert_to()</span></tt></a><a class="headerlink" href="#convert-to" title="Permalink to this headline">¶</a></h3>
<p>This step is relatively straightforward, each <a class="reference internal" href="#brian.experimental.codegen2.CodeItem" title="brian.experimental.codegen2.CodeItem"><tt class="xref py py-class docutils literal"><span class="pre">CodeItem</span></tt></a> object has its
<tt class="docutils literal"><span class="pre">convert_to</span></tt> method called iteratively. The important one is in
<a class="reference internal" href="#brian.experimental.codegen2.MathematicalStatement" title="brian.experimental.codegen2.MathematicalStatement"><tt class="xref py py-class docutils literal"><span class="pre">MathematicalStatement</span></tt></a>, where the left hand side usage is replaced by
<a class="reference internal" href="#brian.experimental.codegen2.Symbol.write" title="brian.experimental.codegen2.Symbol.write"><tt class="xref py py-meth docutils literal"><span class="pre">Symbol.write()</span></tt></a> and the right hand side usage is replaced by
<a class="reference internal" href="#brian.experimental.codegen2.Symbol.read" title="brian.experimental.codegen2.Symbol.read"><tt class="xref py py-meth docutils literal"><span class="pre">Symbol.read()</span></tt></a>. In addition, at this stage the syntax of mathematical
statements is corrected, e.g. Python&#8217;s <tt class="docutils literal"><span class="pre">x**y</span></tt> is replaced by C++&#8217;s
<tt class="docutils literal"><span class="pre">pow(x,y)</span></tt> using <tt class="docutils literal"><span class="pre">sympy</span></tt>.</p>
</div>
</div>
<div class="section" id="code-generation-in-brian">
<h2>Code generation in Brian<a class="headerlink" href="#code-generation-in-brian" title="Permalink to this headline">¶</a></h2>
<p>The four objects used for code generation in Brian are:</p>
<dl class="docutils">
<dt><a class="reference internal" href="#brian.experimental.codegen2.CodeGenStateUpdater" title="brian.experimental.codegen2.CodeGenStateUpdater"><tt class="xref py py-class docutils literal"><span class="pre">CodeGenStateUpdater</span></tt></a></dt>
<dd>Used for numerical integration, see above and reference documentation.</dd>
<dt><a class="reference internal" href="#brian.experimental.codegen2.CodeGenThreshold" title="brian.experimental.codegen2.CodeGenThreshold"><tt class="xref py py-class docutils literal"><span class="pre">CodeGenThreshold</span></tt></a></dt>
<dd>Used for computing a threshold function.</dd>
<dt><a class="reference internal" href="#brian.experimental.codegen2.CodeGenReset" title="brian.experimental.codegen2.CodeGenReset"><tt class="xref py py-class docutils literal"><span class="pre">CodeGenReset</span></tt></a></dt>
<dd>Used for computing post-spike reset.</dd>
<dt><a class="reference internal" href="#brian.experimental.codegen2.CodeGenConnection" title="brian.experimental.codegen2.CodeGenConnection"><tt class="xref py py-class docutils literal"><span class="pre">CodeGenConnection</span></tt></a></dt>
<dd>Used for synaptic propagation.</dd>
</dl>
<div class="section" id="numerical-integration">
<h3>Numerical integration<a class="headerlink" href="#numerical-integration" title="Permalink to this headline">¶</a></h3>
<p>An integration scheme is generated from an <tt class="xref py py-class docutils literal"><span class="pre">Equations</span></tt> object using the
<a class="reference internal" href="#brian.experimental.codegen2.make_integration_step" title="brian.experimental.codegen2.make_integration_step"><tt class="xref py py-func docutils literal"><span class="pre">make_integration_step()</span></tt></a> function. See reference documentation for that
function for details.</p>
<p>This is carried out by <a class="reference internal" href="#brian.experimental.codegen2.CodeGenStateUpdater" title="brian.experimental.codegen2.CodeGenStateUpdater"><tt class="xref py py-class docutils literal"><span class="pre">CodeGenStateUpdater</span></tt></a>, which can be used as a
Brian <tt class="xref py py-class docutils literal"><span class="pre">brian.StateUpdater</span></tt> object in <a class="reference internal" href="reference-models-and-groups.html#brian.NeuronGroup" title="brian.NeuronGroup"><tt class="xref py py-class docutils literal"><span class="pre">brian.NeuronGroup</span></tt></a>.</p>
<p>As an example, for Euler integration, the differential equations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dx</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="n">expr</span>
</pre></div>
</div>
<p>are separated by <tt class="xref py py-class docutils literal"><span class="pre">Equations</span></tt> into variable <tt class="docutils literal"><span class="pre">x</span></tt> with expression
<tt class="docutils literal"><span class="pre">expr</span></tt>. This then becomes:</p>
<div class="highlight-python"><pre>_temp_x := expr
x += _temp_x*dt</pre>
</div>
<p>This can then be resolved by the code generation mechanisms described already.</p>
</div>
<div class="section" id="synaptic-propagation">
<h3>Synaptic propagation<a class="headerlink" href="#synaptic-propagation" title="Permalink to this headline">¶</a></h3>
<p>TODO: synaptic propagation, including docstrings and code comments</p>
<p>NOTE: GPU functionality not included for synaptic propagation yet.</p>
</div>
</div>
<div class="section" id="gpu">
<h2>GPU<a class="headerlink" href="#gpu" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">GPU code is highly transitional, many details may change in the future.</p>
</div>
<p>GPU code is handled by five classes:</p>
<dl class="docutils">
<dt><a class="reference internal" href="#brian.experimental.codegen2.GPULanguage" title="brian.experimental.codegen2.GPULanguage"><tt class="xref py py-class docutils literal"><span class="pre">GPULanguage</span></tt></a> (derived from <a class="reference internal" href="#brian.experimental.codegen2.CLanguage" title="brian.experimental.codegen2.CLanguage"><tt class="xref py py-class docutils literal"><span class="pre">CLanguage</span></tt></a>)</dt>
<dd>Identifies the language as CUDA, and stores a singleton
<a class="reference internal" href="#brian.experimental.codegen2.GPUManager" title="brian.experimental.codegen2.GPUManager"><tt class="xref py py-class docutils literal"><span class="pre">GPUManager</span></tt></a> object which is used to manage the GPU.</dd>
<dt><a class="reference internal" href="#brian.experimental.codegen2.GPUCode" title="brian.experimental.codegen2.GPUCode"><tt class="xref py py-class docutils literal"><span class="pre">GPUCode</span></tt></a> (derived from <a class="reference internal" href="#brian.experimental.codegen2.Code" title="brian.experimental.codegen2.Code"><tt class="xref py py-class docutils literal"><span class="pre">Code</span></tt></a>)</dt>
<dd>Returned from the code generation process, but mostly just acts as a proxy
to <a class="reference internal" href="#brian.experimental.codegen2.GPUManager" title="brian.experimental.codegen2.GPUManager"><tt class="xref py py-class docutils literal"><span class="pre">GPUManager</span></tt></a>.</dd>
<dt><a class="reference internal" href="#brian.experimental.codegen2.GPUKernel" title="brian.experimental.codegen2.GPUKernel"><tt class="xref py py-class docutils literal"><span class="pre">GPUKernel</span></tt></a></dt>
<dd>Handles the final stage of taking a partially generated kernel (without the
vectorisation over threads) and computing the final kernel (using
vectorisation over threads). Also adds data to the
<a class="reference internal" href="#brian.experimental.codegen2.GPUSymbolMemoryManager" title="brian.experimental.codegen2.GPUSymbolMemoryManager"><tt class="xref py py-class docutils literal"><span class="pre">GPUSymbolMemoryManager</span></tt></a>.</dd>
<dt><a class="reference internal" href="#brian.experimental.codegen2.GPUManager" title="brian.experimental.codegen2.GPUManager"><tt class="xref py py-class docutils literal"><span class="pre">GPUManager</span></tt></a></dt>
<dd>Manages the GPU generally. Stores a set of kernels (<a class="reference internal" href="#brian.experimental.codegen2.GPUKernel" title="brian.experimental.codegen2.GPUKernel"><tt class="xref py py-class docutils literal"><span class="pre">GPUKernel</span></tt></a>) and
manages memory via <a class="reference internal" href="#brian.experimental.codegen2.GPUSymbolMemoryManager" title="brian.experimental.codegen2.GPUSymbolMemoryManager"><tt class="xref py py-class docutils literal"><span class="pre">GPUSymbolMemoryManager</span></tt></a>. Handles joining the
memory management code and kernel code into a single source file, and
compiling it.</dd>
<dt><a class="reference internal" href="#brian.experimental.codegen2.GPUSymbolMemoryManager" title="brian.experimental.codegen2.GPUSymbolMemoryManager"><tt class="xref py py-class docutils literal"><span class="pre">GPUSymbolMemoryManager</span></tt></a></dt>
<dd>Handles allocation of GPU memory for symbols.</dd>
</dl>
<p>For more details, see the reference documentation for the classes in the order
above.</p>
<p>Note that <a class="reference internal" href="#brian.experimental.codegen2.CodeGenConnection" title="brian.experimental.codegen2.CodeGenConnection"><tt class="xref py py-class docutils literal"><span class="pre">CodeGenConnection</span></tt></a> is the only code generation version of a
Brian class which is not GPU enabled at present.</p>
</div>
<div class="section" id="extending-code-generation">
<h2>Extending code generation<a class="headerlink" href="#extending-code-generation" title="Permalink to this headline">¶</a></h2>
<p>To extend code generation, you will probably need to add new <a class="reference internal" href="#brian.experimental.codegen2.Symbol" title="brian.experimental.codegen2.Symbol"><tt class="xref py py-class docutils literal"><span class="pre">Symbol</span></tt></a>
classes. Read the documentation for this class to start, and the documentation
for the most important symbols:</p>
<ul class="simple">
<li><a class="reference internal" href="#brian.experimental.codegen2.SliceIndex" title="brian.experimental.codegen2.SliceIndex"><tt class="xref py py-class docutils literal"><span class="pre">SliceIndex</span></tt></a></li>
<li><a class="reference internal" href="#brian.experimental.codegen2.ArraySymbol" title="brian.experimental.codegen2.ArraySymbol"><tt class="xref py py-class docutils literal"><span class="pre">ArraySymbol</span></tt></a></li>
<li><a class="reference internal" href="#brian.experimental.codegen2.ArrayIndex" title="brian.experimental.codegen2.ArrayIndex"><tt class="xref py py-class docutils literal"><span class="pre">ArrayIndex</span></tt></a></li>
<li><a class="reference internal" href="#brian.experimental.codegen2.NeuronGroupStateVariableSymbol" title="brian.experimental.codegen2.NeuronGroupStateVariableSymbol"><tt class="xref py py-class docutils literal"><span class="pre">NeuronGroupStateVariableSymbol</span></tt></a></li>
</ul>
<p>See also <a class="reference internal" href="#brian.experimental.codegen2.CodeItem" title="brian.experimental.codegen2.CodeItem"><tt class="xref py py-class docutils literal"><span class="pre">CodeItem</span></tt></a>, particularly the process described in
<a class="reference internal" href="#brian.experimental.codegen2.CodeItem.generate" title="brian.experimental.codegen2.CodeItem.generate"><tt class="xref py py-meth docutils literal"><span class="pre">CodeItem.generate()</span></tt></a>.</p>
</div>
<div class="section" id="inheritance-diagrams">
<h2>Inheritance diagrams<a class="headerlink" href="#inheritance-diagrams" title="Permalink to this headline">¶</a></h2>
<p>The overall structure of the classes in the code generation package are
included below, for reference.</p>
<div class="section" id="languages">
<h3>Languages<a class="headerlink" href="#languages" title="Permalink to this headline">¶</a></h3>
<p class="graphviz">
<img src="_images/inheritance-2ad13cabda3e4ed13b21b52bc0a5e5ef990c25c2.png" alt="Inheritance diagram of brian.experimental.codegen2.languages, GPULanguage" usemap="#inheritancec1e5e1d102" class="inheritance"/>
<map id="inheritancec1e5e1d102" name="inheritancec1e5e1d102">
<area shape="rect" id="node1" title=":class:`Language` object for GPU." alt="" coords="5,161,208,189"/>
<area shape="rect" id="node2" title="C language." alt="" coords="25,83,188,111"/>
<area shape="rect" id="node4" title="Base class for languages, each should provide a ``name`` attribute, and a" alt="" coords="131,6,285,34"/>
<area shape="rect" id="node6" title="Python language." alt="" coords="212,83,409,111"/>
</map>
</p>
</div>
<div class="section" id="code-objects">
<h3>Code objects<a class="headerlink" href="#code-objects" title="Permalink to this headline">¶</a></h3>
<p class="graphviz">
<img src="_images/inheritance-d750d36a5a441a93fb7dd778b014c2aa7a49bec7.png" alt="Inheritance diagram of brian.experimental.codegen2.codeobject, GPUCode" usemap="#inheritance3b17c53725" class="inheritance"/>
<map id="inheritance3b17c53725" name="inheritance3b17c53725">
<area shape="rect" id="node2" title="The basic Code object used for all Python/C/GPU code generation." alt="" coords="225,6,353,34"/>
<area shape="rect" id="node4" title=":class:`Code` object for GPU." alt="" coords="203,83,376,111"/>
</map>
</p>
</div>
<div class="section" id="code-items">
<h3>Code items<a class="headerlink" href="#code-items" title="Permalink to this headline">¶</a></h3>
<p class="graphviz">
<img src="_images/inheritance-06decb1d84bba8103b9066e13c16edc537c9397a.png" alt="Inheritance diagram of brian.experimental.codegen2.codeitems, brian.experimental.codegen2.statements, brian.experimental.codegen2.blocks" usemap="#inheritance49ea690a2f" class="inheritance"/>
<map id="inheritance49ea690a2f" name="inheritance49ea690a2f">
<area shape="rect" id="node1" title="Define a variable from an array and an index in C." alt="" coords="4,197,183,220"/>
<area shape="rect" id="node2" title="A language&#45;specific single line of code, which should only be used in" alt="" coords="10,133,178,156"/>
<area shape="rect" id="node4" title="Just a base class." alt="" coords="377,197,466,220"/>
<area shape="rect" id="node9" title="If statement in C, structure is::" alt="" coords="245,261,340,284"/>
<area shape="rect" id="node15" title="If statement in Python, structure is::" alt="" coords="360,261,483,284"/>
<area shape="rect" id="node5" title="Helper class used as the base for various control structures such as for" alt="" coords="429,133,548,156"/>
<area shape="rect" id="node13" title="Simply a base class, does nothing." alt="" coords="506,197,606,220"/>
<area shape="rect" id="node7" title="Just a base class, supposed to indicate single line statements." alt="" coords="234,69,373,92"/>
<area shape="rect" id="node21" title="A single line mathematical statement." alt="" coords="198,133,409,156"/>
<area shape="rect" id="node11" title="An item of code, can be anything from a single statement corresponding to" alt="" coords="318,5,446,28"/>
<area shape="rect" id="node17" title="Contains a list of :class:`CodeItem` objects which are considered to be" alt="" coords="420,69,502,92"/>
<area shape="rect" id="node12" title="A for loop in C, the structure is::" alt="" coords="503,261,609,284"/>
<area shape="rect" id="node24" title="A for loop in Python, the structure is::" alt="" coords="629,261,764,284"/>
</map>
</p>
</div>
<div class="section" id="equations">
<h3>Equations<a class="headerlink" href="#equations" title="Permalink to this headline">¶</a></h3>
<p class="graphviz">
<img src="_images/inheritance-301814a12f69a6c6fdcd67b3c0317b187f88f887.png" alt="Inheritance diagram of brian.experimental.codegen2.equations, brian.experimental.codegen2.expressions" usemap="#inheritance81f80d91fd" class="inheritance"/>
<map id="inheritance81f80d91fd" name="inheritance81f80d91fd">
<area shape="rect" id="node1" title="A mathematical expression such as ``x*y+z``." alt="" coords="5,6,176,34"/>
</map>
</p>
</div>
<div class="section" id="symbols">
<h3>Symbols<a class="headerlink" href="#symbols" title="Permalink to this headline">¶</a></h3>
<p class="graphviz">
<img src="_images/inheritance-49d616dc0421852cf73827f5c41a02cb289aa76c.png" alt="Inheritance diagram of brian.experimental.codegen2.symbols" usemap="#inheritance294af25cd6" class="inheritance"/>
<map id="inheritance294af25cd6" name="inheritance294af25cd6">
<area shape="rect" id="node1" title="Base class for all symbols." alt="" coords="358,6,481,34"/>
<area shape="rect" id="node3" title="This symbol is used to specify a value taken from an array." alt="" coords="74,82,231,110"/>
<area shape="rect" id="node5" title="Multi&#45;valued symbol giving an index that iterates through an array." alt="" coords="255,82,400,110"/>
<area shape="rect" id="node7" title="This Symbol is guaranteed by the context to be inserted into the namespace" alt="" coords="423,82,600,110"/>
<area shape="rect" id="node9" title="Multi&#45;valued symbol that ranges over a slice." alt="" coords="623,82,763,110"/>
<area shape="rect" id="node2" title="Symbol for a state variable." alt="" coords="5,158,300,186"/>
</map>
</p>
</div>
<div class="section" id="resolution-and-code-output">
<h3>Resolution and code output<a class="headerlink" href="#resolution-and-code-output" title="Permalink to this headline">¶</a></h3>
<p class="graphviz">
<img src="_images/inheritance-bfb6cf81232dfc1b904c9658c1ee0ff9ac98f20e.png" alt="Inheritance diagram of brian.experimental.codegen2.dependencies, brian.experimental.codegen2.formatting" usemap="#inheritance3f4c903e03" class="inheritance"/>
<map id="inheritance3f4c903e03" name="inheritance3f4c903e03">
<area shape="rect" id="node1" title="Base class for :class:`Read` and :class:`Write` dependencies." alt="" coords="67,6,261,34"/>
<area shape="rect" id="node2" title="Used to indicate a read dependency, i.e. the value of the symbol is read." alt="" coords="5,83,152,111"/>
<area shape="rect" id="node4" title="Used to indicate a write dependency, i.e. the value of the symbol is" alt="" coords="176,83,323,111"/>
</map>
</p>
</div>
<div class="section" id="integration">
<h3>Integration<a class="headerlink" href="#integration" title="Permalink to this headline">¶</a></h3>
<p class="graphviz">
<img src="_images/inheritance-523581f6dda5a5f1c6a1847ef5131f03e629ef16.png" alt="Inheritance diagram of brian.experimental.codegen2.integration" usemap="#inheritance829fb7dcae" class="inheritance"/>
<map id="inheritance829fb7dcae" name="inheritance829fb7dcae">
<area shape="rect" id="node1" title="Utility class for defining numerical integration scheme" alt="" coords="5,6,224,34"/>
</map>
</p>
</div>
<div class="section" id="id1">
<h3>GPU<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p class="graphviz">
<img src="_images/inheritance-5d32a6765c2ea786b2968d668e0bcc8e95c0ac64.png" alt="Inheritance diagram of brian.experimental.codegen2.gpu.management" usemap="#inheritance0591f2880e" class="inheritance"/>
<map id="inheritance0591f2880e" name="inheritance0591f2880e">
<area shape="rect" id="node1" title="Manages symbol memory on the GPU." alt="" coords="4,4,218,25"/>
<area shape="rect" id="node2" title="Base class for languages, each should provide a ``name`` attribute, and a" alt="" coords="235,4,347,25"/>
<area shape="rect" id="node4" title="C language." alt="" coords="233,60,350,81"/>
<area shape="rect" id="node3" title=":class:`Language` object for GPU." alt="" coords="218,116,365,137"/>
<area shape="rect" id="node6" title="Generates final kernel source code and used to launch kernels." alt="" coords="365,4,494,25"/>
<area shape="rect" id="node8" title=":class:`Code` object for GPU." alt="" coords="495,60,620,81"/>
<area shape="rect" id="node9" title="The basic Code object used for all Python/C/GPU code generation." alt="" coords="511,4,604,25"/>
<area shape="rect" id="node11" title="This object controls everything on the GPU." alt="" coords="621,4,764,25"/>
</map>
</p>
</div>
<div class="section" id="brian-objects">
<h3>Brian objects<a class="headerlink" href="#brian-objects" title="Permalink to this headline">¶</a></h3>
<div class="section" id="connection">
<h4>Connection<a class="headerlink" href="#connection" title="Permalink to this headline">¶</a></h4>
<p class="graphviz">
<img src="_images/inheritance-36d44d4047bc77bfc66e26c04fc37e62f4ac5f06.png" alt="Inheritance diagram of brian.experimental.codegen2.connection" usemap="#inheritanceb81e6896c4" class="inheritance"/>
<map id="inheritanceb81e6896c4" name="inheritanceb81e6896c4">
<area shape="rect" id="node2" title="Mechanism for propagating spikes from one group to another" alt="" coords="66,59,242,79"/>
<area shape="rect" id="node5" title="Base class for all classes whose instances are to be tracked" alt="" coords="4,4,146,24"/>
<area shape="rect" id="node7" title="Implements the contained_objects protocol" alt="" coords="163,4,302,24"/>
</map>
</p>
</div>
<div class="section" id="reset">
<h4>Reset<a class="headerlink" href="#reset" title="Permalink to this headline">¶</a></h4>
<p class="graphviz">
<img src="_images/inheritance-dcf9028d36cab8f11398c246581bd3d801f3ed30.png" alt="Inheritance diagram of brian.experimental.codegen2.reset" usemap="#inheritancec898c06c9b" class="inheritance"/>
<map id="inheritancec898c06c9b" name="inheritancec898c06c9b">
<area shape="rect" id="node2" title="Resets specified state variable to a fixed value" alt="" coords="49,6,180,34"/>
</map>
</p>
</div>
<div class="section" id="state-updater">
<h4>State updater<a class="headerlink" href="#state-updater" title="Permalink to this headline">¶</a></h4>
<p class="graphviz">
<img src="_images/inheritance-45c1f1806993b13c5d198893d2321aa84101a76f.png" alt="Inheritance diagram of brian.experimental.codegen2.stateupdater" usemap="#inheritancefd14b864b8" class="inheritance"/>
<map id="inheritancefd14b864b8" name="inheritancefd14b864b8">
<area shape="rect" id="node1" title="State updater using code generation, supports Python, C++, GPU." alt="" coords="5,83,325,111"/>
<area shape="rect" id="node2" title="A callable state update mechanism." alt="" coords="51,6,280,34"/>
</map>
</p>
</div>
<div class="section" id="threshold">
<h4>Threshold<a class="headerlink" href="#threshold" title="Permalink to this headline">¶</a></h4>
<p class="graphviz">
<img src="_images/inheritance-d24e800862348c107548ccf5ba891dc697b8c6eb.png" alt="Inheritance diagram of brian.experimental.codegen2.threshold" usemap="#inheritancec0e1344a8c" class="inheritance"/>
<map id="inheritancec0e1344a8c" name="inheritancec0e1344a8c">
<area shape="rect" id="node1" title="All neurons with a specified state variable above a fixed value fire a spike." alt="" coords="49,6,233,34"/>
<area shape="rect" id="node3" title="Base class for all symbols." alt="" coords="340,6,535,34"/>
</map>
</p>
</div>
</div>
</div>
<div class="section" id="reference">
<h2>Reference<a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="blocks">
<h3>blocks<a class="headerlink" href="#blocks" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="brian.experimental.codegen2.Block">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">Block</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Block" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains a list of <a class="reference internal" href="#brian.experimental.codegen2.CodeItem" title="brian.experimental.codegen2.CodeItem"><tt class="xref py py-class docutils literal"><span class="pre">CodeItem</span></tt></a> objects which are considered to be
executed in serial order. The list is passed as arguments to the
init method, so if you want to pass a list you can initialise as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">block</span> <span class="o">=</span> <span class="n">Block</span><span class="p">(</span><span class="o">*</span><span class="n">items</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.ControlBlock">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">ControlBlock</tt><big>(</big><em>start</em>, <em>end</em>, <em>contents</em>, <em>dependencies</em>, <em>resolved</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.ControlBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper class used as the base for various control structures such as for
loops, if statements. These are typically not language-invariant and
should only be output in the resolution process by symbols (which know the
language they are resolving to). Consists of strings <tt class="docutils literal"><span class="pre">start</span></tt> and <tt class="docutils literal"><span class="pre">end</span></tt>,
a list of <tt class="docutils literal"><span class="pre">contents</span></tt> (as for <a class="reference internal" href="#brian.experimental.codegen2.Block" title="brian.experimental.codegen2.Block"><tt class="xref py py-class docutils literal"><span class="pre">Block</span></tt></a>), and explicit sets of 
<tt class="docutils literal"><span class="pre">dependencies</span></tt> and <tt class="docutils literal"><span class="pre">resolved</span></tt> (these are self-dependencies/resolved).
The output code consists of the start string, the indented converted
contents, and then the end string. For example, for a C for loop, we would
have <tt class="docutils literal"><span class="pre">start='for(...){</span></tt> and <tt class="docutils literal"><span class="pre">end='}'</span></tt>.</p>
<dl class="method">
<dt id="brian.experimental.codegen2.ControlBlock.convert_to">
<tt class="descname">convert_to</tt><big>(</big><em>language</em>, <em>symbols={}</em>, <em>namespace={}</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.ControlBlock.convert_to" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.ForBlock">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">ForBlock</tt><big>(</big><em>start</em>, <em>end</em>, <em>contents</em>, <em>dependencies</em>, <em>resolved</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.ForBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Simply a base class, does nothing.</p>
</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.PythonForBlock">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">PythonForBlock</tt><big>(</big><em>var</em>, <em>container</em>, <em>content</em>, <em>dependencies=None</em>, <em>resolved=None</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.PythonForBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>A for loop in Python, the structure is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">container</span><span class="p">:</span>
    <span class="n">content</span>
</pre></div>
</div>
<p>Where <tt class="docutils literal"><span class="pre">var</span></tt> and <tt class="docutils literal"><span class="pre">container</span></tt> are strings, and <tt class="docutils literal"><span class="pre">content</span></tt> is a
<a class="reference internal" href="#brian.experimental.codegen2.CodeItem" title="brian.experimental.codegen2.CodeItem"><tt class="xref py py-class docutils literal"><span class="pre">CodeItem</span></tt></a> or list of items.</p>
<p>Dependencies can be given explicitly, or by default they are <tt class="docutils literal"><span class="pre">Read(x)</span></tt> for
each word <tt class="docutils literal"><span class="pre">x</span></tt> in <tt class="docutils literal"><span class="pre">container</span></tt>. Resolved can be given explicitly, or by
default it is <tt class="docutils literal"><span class="pre">set(var)</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.CForBlock">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">CForBlock</tt><big>(</big><em>var</em>, <em>spec</em>, <em>content</em>, <em>dependencies=None</em>, <em>resolved=None</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.CForBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>A for loop in C, the structure is:</p>
<div class="highlight-python"><pre>for(spec)
{
    content
}</pre>
</div>
<p>You specify a string <tt class="docutils literal"><span class="pre">var</span></tt> which is the variable the loop is iterating
over, and a string <tt class="docutils literal"><span class="pre">spec</span></tt> should be of the form <tt class="docutils literal"><span class="pre">'int</span> <span class="pre">i=0;</span> <span class="pre">i&lt;n;</span> <span class="pre">i++'</span></tt>.
The <tt class="docutils literal"><span class="pre">content</span></tt> is a <a class="reference internal" href="#brian.experimental.codegen2.CodeItem" title="brian.experimental.codegen2.CodeItem"><tt class="xref py py-class docutils literal"><span class="pre">CodeItem</span></tt></a> or list of items. The dependencies
and resolved sets can be given explicitly, or by default they are extracted,
respectively, from the set of words in <tt class="docutils literal"><span class="pre">spec</span></tt>, and <tt class="docutils literal"><span class="pre">set([var])</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.IfBlock">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">IfBlock</tt><big>(</big><em>start</em>, <em>end</em>, <em>contents</em>, <em>dependencies</em>, <em>resolved</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.IfBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Just a base class.</p>
</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.PythonIfBlock">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">PythonIfBlock</tt><big>(</big><em>cond</em>, <em>content</em>, <em>dependencies=None</em>, <em>resolved=None</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.PythonIfBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>If statement in Python, structure is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">cond</span><span class="p">:</span>
    <span class="n">content</span>
</pre></div>
</div>
<p>Dependencies can be specified explicitly, or are automatically extracted as
the words in string <tt class="docutils literal"><span class="pre">cond</span></tt>, and resolved can be specified explicitly or by
default is <tt class="docutils literal"><span class="pre">set()</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.CIfBlock">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">CIfBlock</tt><big>(</big><em>cond</em>, <em>content</em>, <em>dependencies=None</em>, <em>resolved=None</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.CIfBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>If statement in C, structure is:</p>
<div class="highlight-python"><pre>if(cond)
{
    content
}</pre>
</div>
<p>Dependencies can be specified explicitly, or are automatically extracted as
the words in string <tt class="docutils literal"><span class="pre">cond</span></tt>, and resolved can be specified explicitly or by
default is <tt class="docutils literal"><span class="pre">set()</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="codeitems">
<h3>codeitems<a class="headerlink" href="#codeitems" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="brian.experimental.codegen2.CodeItem">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">CodeItem</tt><a class="headerlink" href="#brian.experimental.codegen2.CodeItem" title="Permalink to this definition">¶</a></dt>
<dd><p>An item of code, can be anything from a single statement corresponding to
a single line of code, right up to a block with nested loops, etc.</p>
<p>Should define the following attributes (default values are provided):</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">resolved</span></tt></dt>
<dd>The set of dependencies which have been resolved in this item, including
in items contained within this item. Default value: the union of
<tt class="docutils literal"><span class="pre">selfresolved</span></tt> and <tt class="docutils literal"><span class="pre">subresolved</span></tt>. Elements of the set should be
of type <a class="reference internal" href="#brian.experimental.codegen2.Dependency" title="brian.experimental.codegen2.Dependency"><tt class="xref py py-class docutils literal"><span class="pre">Dependency</span></tt></a> (i.e. <a class="reference internal" href="#brian.experimental.codegen2.Read" title="brian.experimental.codegen2.Read"><tt class="xref py py-class docutils literal"><span class="pre">Read</span></tt></a> or <a class="reference internal" href="#brian.experimental.codegen2.Write" title="brian.experimental.codegen2.Write"><tt class="xref py py-class docutils literal"><span class="pre">Write</span></tt></a>).</dd>
<dt><tt class="docutils literal"><span class="pre">selfresolved</span></tt></dt>
<dd>The set of dependencies resolved only in this item, and not in subitems.
Default value: <tt class="docutils literal"><span class="pre">set()</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">subresolved</span></tt></dt>
<dd>The set of dependencies resolved in subitems, default value is the
union of <tt class="docutils literal"><span class="pre">item.dependencies</span></tt> for each <tt class="docutils literal"><span class="pre">item</span></tt> in this item.
Requires the <a class="reference internal" href="#brian.experimental.codegen2.CodeItem" title="brian.experimental.codegen2.CodeItem"><tt class="xref py py-class docutils literal"><span class="pre">CodeItem</span></tt></a> to have an iterator, i.e. a method
<tt class="docutils literal"><span class="pre">__iter__</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">dependencies</span></tt>, <tt class="docutils literal"><span class="pre">selfdependencies</span></tt>, <tt class="docutils literal"><span class="pre">subdependencies</span></tt></dt>
<dd>As above for resolved, but giving the set of dependencies in this code.
The default value for <tt class="docutils literal"><span class="pre">dependencies</span></tt> takes the union of
<tt class="docutils literal"><span class="pre">selfdependencies</span></tt> and <tt class="docutils literal"><span class="pre">subdependencies</span></tt> and removes all the
symbols in <tt class="docutils literal"><span class="pre">resolved</span></tt>.</dd>
</dl>
<p>This structure of having default implementations allows several routes to
derive a class from here, e.g.:</p>
<dl class="docutils">
<dt><a class="reference internal" href="#brian.experimental.codegen2.Block" title="brian.experimental.codegen2.Block"><tt class="xref py py-class docutils literal"><span class="pre">Block</span></tt></a></dt>
<dd>Simply defines a list attribute <tt class="docutils literal"><span class="pre">contents</span></tt> which is a sequence of
items, and implements <tt class="docutils literal"><span class="pre">__iter__</span></tt> to return <tt class="docutils literal"><span class="pre">iter(contents)</span></tt>.</dd>
<dt><a class="reference internal" href="#brian.experimental.codegen2.CodeStatement" title="brian.experimental.codegen2.CodeStatement"><tt class="xref py py-class docutils literal"><span class="pre">CodeStatement</span></tt></a></dt>
<dd>Defines a fixed string which is not language-invariant, and a fixed
set of dependencies and resolved. The <a class="reference internal" href="#brian.experimental.codegen2.CodeItem.convert_to" title="brian.experimental.codegen2.CodeItem.convert_to"><tt class="xref py py-meth docutils literal"><span class="pre">convert_to()</span></tt></a> method simply
returns the fixed string. Does not define an <tt class="docutils literal"><span class="pre">__iter__</span></tt> method because
the default values for <tt class="docutils literal"><span class="pre">dependencies</span></tt> and <tt class="docutils literal"><span class="pre">resolved</span></tt> are
overwritten.</dd>
</dl>
<dl class="method">
<dt id="brian.experimental.codegen2.CodeItem.convert_to">
<tt class="descname">convert_to</tt><big>(</big><em>language</em>, <em>symbols={}</em>, <em>namespace={}</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.CodeItem.convert_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string representation of the code for this item in the given
language. From the user point of view, you should call
<a class="reference internal" href="#brian.experimental.codegen2.CodeItem.generate" title="brian.experimental.codegen2.CodeItem.generate"><tt class="xref py py-meth docutils literal"><span class="pre">generate()</span></tt></a>, but in developing new <a class="reference internal" href="#brian.experimental.codegen2.CodeItem" title="brian.experimental.codegen2.CodeItem"><tt class="xref py py-class docutils literal"><span class="pre">CodeItem</span></tt></a> derived
classes you need to implement this. The default behaviour is simply
to concatenate the strings returned by the subitems.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.CodeItem.generate">
<tt class="descname">generate</tt><big>(</big><em>name</em>, <em>language</em>, <em>symbols</em>, <em>namespace=None</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.CodeItem.generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#brian.experimental.codegen2.Code" title="brian.experimental.codegen2.Code"><tt class="xref py py-class docutils literal"><span class="pre">Code</span></tt></a> object. The method resolves the symbols using
<a class="reference internal" href="#brian.experimental.codegen2.resolve" title="brian.experimental.codegen2.resolve"><tt class="xref py py-func docutils literal"><span class="pre">resolve()</span></tt></a>, converts to a string with <a class="reference internal" href="#brian.experimental.codegen2.CodeItem.convert_to" title="brian.experimental.codegen2.CodeItem.convert_to"><tt class="xref py py-meth docutils literal"><span class="pre">convert_to()</span></tt></a> and then
converts that to a <a class="reference internal" href="#brian.experimental.codegen2.Code" title="brian.experimental.codegen2.Code"><tt class="xref py py-class docutils literal"><span class="pre">Code</span></tt></a> object with
<a class="reference internal" href="#brian.experimental.codegen2.Language.code_object" title="brian.experimental.codegen2.Language.code_object"><tt class="xref py py-meth docutils literal"><span class="pre">Language.code_object()</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="brian.experimental.codegen2.CodeItem.subdependencies">
<tt class="descname">subdependencies</tt><a class="headerlink" href="#brian.experimental.codegen2.CodeItem.subdependencies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="brian.experimental.codegen2.CodeItem.subresolved">
<tt class="descname">subresolved</tt><a class="headerlink" href="#brian.experimental.codegen2.CodeItem.subresolved" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="codeobject">
<h3>codeobject<a class="headerlink" href="#codeobject" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="brian.experimental.codegen2.Code">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">Code</tt><big>(</big><em>name</em>, <em>code_str</em>, <em>namespace</em>, <em>pre_code=None</em>, <em>post_code=None</em>, <em>language=None</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Code" title="Permalink to this definition">¶</a></dt>
<dd><p>The basic Code object used for all Python/C/GPU code generation.</p>
<p>The Code object has the following attributes:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">name</span></tt></dt>
<dd>The name of the code, should be unique. This matters particularly
for GPU code which uses the name attribute for the kernel function
names.</dd>
<dt><tt class="docutils literal"><span class="pre">code_str</span></tt></dt>
<dd>A representation of the code in string form</dd>
<dt><tt class="docutils literal"><span class="pre">namespace</span></tt></dt>
<dd>A dictionary of name/value pairs in which the code will be
executed</dd>
<dt><tt class="docutils literal"><span class="pre">code_compiled</span></tt></dt>
<dd>An optional value (can be None) consisting of some representation of the
compiled form of the code</dd>
<dt><tt class="docutils literal"><span class="pre">pre_code</span></tt>, <tt class="docutils literal"><span class="pre">post_code</span></tt></dt>
<dd>Two optional Code objects which can be in the same or different
languages, and can share partially or wholly the namespace. They are
called (respectively) before or after the current code object is
executed.</dd>
<dt><tt class="docutils literal"><span class="pre">language</span></tt></dt>
<dd>A <a class="reference internal" href="#brian.experimental.codegen2.Language" title="brian.experimental.codegen2.Language"><tt class="xref py py-class docutils literal"><span class="pre">Language</span></tt></a> object that stores some global settings and state
for all code in that language.</dd>
</dl>
<p>Each language (e.g. PythonCode) extends some or all of the methods:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">__init__(...)</span></tt></dt>
<dd>Unsurprisingly used for initialising the object, should call
Code.__init__ with all of its arguments.</dd>
<dt><tt class="docutils literal"><span class="pre">compile()</span></tt></dt>
<dd>Compiles the code, if necessary. If not necessary, set the
<tt class="docutils literal"><span class="pre">code_compiled</span></tt> value to any dummy value other than None.</dd>
<dt><tt class="docutils literal"><span class="pre">run()</span></tt></dt>
<dd>Runs the compiled code in the namespace.</dd>
</dl>
<p>It will usually not be necessary to override the call mechanism:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">__call__(**kwds)</span></tt></dt>
<dd>Calls <tt class="docutils literal"><span class="pre">pre_code(**kwds)</span></tt>, updates the namespace with <tt class="docutils literal"><span class="pre">kwds</span></tt>,
executes the code (calls <tt class="docutils literal"><span class="pre">self.run()</span></tt>) and then calls
<tt class="docutils literal"><span class="pre">post_code(**kwds)</span></tt>.</dd>
</dl>
<dl class="method">
<dt id="brian.experimental.codegen2.Code.compile">
<tt class="descname">compile</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Code.compile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.Code.run">
<tt class="descname">run</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Code.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.PythonCode">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">PythonCode</tt><big>(</big><em>name</em>, <em>code_str</em>, <em>namespace</em>, <em>pre_code=None</em>, <em>post_code=None</em>, <em>language=None</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.PythonCode" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="brian.experimental.codegen2.PythonCode.compile">
<tt class="descname">compile</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.PythonCode.compile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.PythonCode.run">
<tt class="descname">run</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.PythonCode.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.CCode">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">CCode</tt><big>(</big><em>name</em>, <em>code_str</em>, <em>namespace</em>, <em>pre_code=None</em>, <em>post_code=None</em>, <em>language=None</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.CCode" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="brian.experimental.codegen2.CCode.run">
<tt class="descname">run</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.CCode.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="id2">
<h3>connection<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="brian.experimental.codegen2.CodeGenConnection">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">CodeGenConnection</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.CodeGenConnection" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="brian.experimental.codegen2.CodeGenConnection.propagate">
<tt class="descname">propagate</tt><big>(</big><em>spikes</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.CodeGenConnection.propagate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.DenseMatrixSymbols">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">DenseMatrixSymbols</tt><a class="headerlink" href="#brian.experimental.codegen2.DenseMatrixSymbols" title="Permalink to this definition">¶</a></dt>
<dd><dl class="class">
<dt id="brian.experimental.codegen2.DenseMatrixSymbols.SynapseIndex">
<em class="property">class </em><tt class="descname">SynapseIndex</tt><big>(</big><em>M</em>, <em>name</em>, <em>weightname</em>, <em>language</em>, <em>sourceindex='_source_index'</em>, <em>targetlen='_target_len'</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.DenseMatrixSymbols.SynapseIndex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="brian.experimental.codegen2.DenseMatrixSymbols.SynapseIndex.resolve">
<tt class="descname">resolve</tt><big>(</big><em>read</em>, <em>write</em>, <em>vectorisable</em>, <em>item</em>, <em>namespace</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.DenseMatrixSymbols.SynapseIndex.resolve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.DenseMatrixSymbols.TargetIndex">
<em class="property">class </em><tt class="descclassname">DenseMatrixSymbols.</tt><tt class="descname">TargetIndex</tt><big>(</big><em>M</em>, <em>name</em>, <em>weightname</em>, <em>language</em>, <em>index='_synapse_index'</em>, <em>targetlen='_target_len'</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.DenseMatrixSymbols.TargetIndex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="brian.experimental.codegen2.DenseMatrixSymbols.TargetIndex.dependencies">
<tt class="descname">dependencies</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.DenseMatrixSymbols.TargetIndex.dependencies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.DenseMatrixSymbols.TargetIndex.load">
<tt class="descname">load</tt><big>(</big><em>read</em>, <em>write</em>, <em>vectorisable</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.DenseMatrixSymbols.TargetIndex.load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="brian.experimental.codegen2.DenseMatrixSymbols.TargetIndex.supported_languages">
<tt class="descname">supported_languages</tt><em class="property"> = ['python', 'c']</em><a class="headerlink" href="#brian.experimental.codegen2.DenseMatrixSymbols.TargetIndex.supported_languages" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.DenseMatrixSymbols.Value">
<em class="property">class </em><tt class="descclassname">DenseMatrixSymbols.</tt><tt class="descname">Value</tt><big>(</big><em>M</em>, <em>name</em>, <em>language</em>, <em>index='_synapse_index'</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.DenseMatrixSymbols.Value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.SparseMatrixSymbols">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">SparseMatrixSymbols</tt><a class="headerlink" href="#brian.experimental.codegen2.SparseMatrixSymbols" title="Permalink to this definition">¶</a></dt>
<dd><dl class="class">
<dt id="brian.experimental.codegen2.SparseMatrixSymbols.SynapseIndex">
<em class="property">class </em><tt class="descname">SynapseIndex</tt><big>(</big><em>M</em>, <em>name</em>, <em>weightname</em>, <em>language</em>, <em>sourceindex='_source_index'</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.SparseMatrixSymbols.SynapseIndex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="brian.experimental.codegen2.SparseMatrixSymbols.SynapseIndex.resolve">
<tt class="descname">resolve</tt><big>(</big><em>read</em>, <em>write</em>, <em>vectorisable</em>, <em>item</em>, <em>namespace</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.SparseMatrixSymbols.SynapseIndex.resolve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.SparseMatrixSymbols.TargetIndex">
<em class="property">class </em><tt class="descclassname">SparseMatrixSymbols.</tt><tt class="descname">TargetIndex</tt><big>(</big><em>M</em>, <em>name</em>, <em>weightname</em>, <em>language</em>, <em>index='_synapse_index'</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.SparseMatrixSymbols.TargetIndex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.SparseMatrixSymbols.Value">
<em class="property">class </em><tt class="descclassname">SparseMatrixSymbols.</tt><tt class="descname">Value</tt><big>(</big><em>M</em>, <em>name</em>, <em>language</em>, <em>index='_synapse_index'</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.SparseMatrixSymbols.Value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="dependencies">
<h3>dependencies<a class="headerlink" href="#dependencies" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="brian.experimental.codegen2.Dependency">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">Dependency</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Dependency" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for <a class="reference internal" href="#brian.experimental.codegen2.Read" title="brian.experimental.codegen2.Read"><tt class="xref py py-class docutils literal"><span class="pre">Read</span></tt></a> and <a class="reference internal" href="#brian.experimental.codegen2.Write" title="brian.experimental.codegen2.Write"><tt class="xref py py-class docutils literal"><span class="pre">Write</span></tt></a> dependencies.</p>
<p>A dependency marks that a <a class="reference internal" href="#brian.experimental.codegen2.CodeItem" title="brian.experimental.codegen2.CodeItem"><tt class="xref py py-class docutils literal"><span class="pre">CodeItem</span></tt></a> depends on a given symbol.
Each dependency has a <tt class="docutils literal"><span class="pre">name</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.Read">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">Read</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Read" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to indicate a read dependency, i.e. the value of the symbol is read.</p>
</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.Write">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">Write</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Write" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to indicate a write dependency, i.e. the value of the symbol is
written to.</p>
</dd></dl>

<dl class="function">
<dt id="brian.experimental.codegen2.get_read_or_write_dependencies">
<tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">get_read_or_write_dependencies</tt><big>(</big><em>dependencies</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.get_read_or_write_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set of names of the variables which are either read to or
written to in a set of dependencies.</p>
</dd></dl>

</div>
<div class="section" id="id3">
<h3>equations<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="brian.experimental.codegen2.freeze_with_equations">
<tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">freeze_with_equations</tt><big>(</big><em>inputcode</em>, <em>eqs</em>, <em>ns</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.freeze_with_equations" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a frozen version of <tt class="docutils literal"><span class="pre">inputcode</span></tt> with equations and namespace.</p>
<p>Replaces each occurrence in <tt class="docutils literal"><span class="pre">inputcode</span></tt> of a variable name in the
namespace <tt class="docutils literal"><span class="pre">ns</span></tt> with its value if it is of int or float type. Variables
with names in <a class="reference internal" href="reference-models-and-groups.html#brian.Equations" title="brian.Equations"><tt class="xref py py-class docutils literal"><span class="pre">brian.Equations</span></tt></a> <tt class="docutils literal"><span class="pre">eqs</span></tt> are not replaced, and neither
are <tt class="docutils literal"><span class="pre">dt</span></tt> or <tt class="docutils literal"><span class="pre">t</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="brian.experimental.codegen2.frozen_equations">
<tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">frozen_equations</tt><big>(</big><em>eqs</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.frozen_equations" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a frozen set of equations.</p>
<p>Each expression defining an equation is frozen as in
<a class="reference internal" href="#brian.experimental.codegen2.freeze_with_equations" title="brian.experimental.codegen2.freeze_with_equations"><tt class="xref py py-func docutils literal"><span class="pre">freeze_with_equations()</span></tt></a>.</p>
</dd></dl>

</div>
<div class="section" id="expressions">
<h3>expressions<a class="headerlink" href="#expressions" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="brian.experimental.codegen2.Expression">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">Expression</tt><big>(</big><em>expr</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Expression" title="Permalink to this definition">¶</a></dt>
<dd><p>A mathematical expression such as <tt class="docutils literal"><span class="pre">x*y+z</span></tt>.</p>
<p>Has an attribute <tt class="docutils literal"><span class="pre">dependencies</span></tt> which is <tt class="docutils literal"><span class="pre">Read(var)</span></tt> for all words
<tt class="docutils literal"><span class="pre">var</span></tt> in <tt class="docutils literal"><span class="pre">expr</span></tt>.</p>
<p>Has a method <a class="reference internal" href="#brian.experimental.codegen2.Expression.convert_to" title="brian.experimental.codegen2.Expression.convert_to"><tt class="xref py py-meth docutils literal"><span class="pre">convert_to()</span></tt></a> defined the same way as
<a class="reference internal" href="#brian.experimental.codegen2.CodeItem.convert_to" title="brian.experimental.codegen2.CodeItem.convert_to"><tt class="xref py py-meth docutils literal"><span class="pre">CodeItem.convert_to()</span></tt></a>.</p>
<dl class="method">
<dt id="brian.experimental.codegen2.Expression.convert_to">
<tt class="descname">convert_to</tt><big>(</big><em>language</em>, <em>symbols={}</em>, <em>namespace={}</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Expression.convert_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts expression into a string for the given <tt class="docutils literal"><span class="pre">language</span></tt> using the
given set of <tt class="docutils literal"><span class="pre">symbols</span></tt>. Replaces each <a class="reference internal" href="#brian.experimental.codegen2.Symbol" title="brian.experimental.codegen2.Symbol"><tt class="xref py py-class docutils literal"><span class="pre">Symbol</span></tt></a> appearing in the
expression with <tt class="docutils literal"><span class="pre">sym.read()</span></tt>, and if the language is C++ or GPU then
uses <tt class="docutils literal"><span class="pre">sympy.CCodePrinter().doprint()</span></tt> to convert the syntax, e.g.
<tt class="docutils literal"><span class="pre">x**y</span></tt> becomes <tt class="docutils literal"><span class="pre">pow(x,y)</span></tt>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="formatting">
<h3>formatting<a class="headerlink" href="#formatting" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="brian.experimental.codegen2.word_substitute">
<tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">word_substitute</tt><big>(</big><em>expr</em>, <em>substitutions</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.word_substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a dict of word substitutions.</p>
<p>The dict <tt class="docutils literal"><span class="pre">substitutions</span></tt> consists of pairs <tt class="docutils literal"><span class="pre">(word,</span> <span class="pre">rep)</span></tt> where each
word <tt class="docutils literal"><span class="pre">word</span></tt> appearing in <tt class="docutils literal"><span class="pre">expr</span></tt> is replaced by <tt class="docutils literal"><span class="pre">rep</span></tt>. Here a &#8216;word&#8217;
means anything matching the regexp <tt class="docutils literal"><span class="pre">\bword\b</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="brian.experimental.codegen2.flattened_docstring">
<tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">flattened_docstring</tt><big>(</big><em>docstr</em>, <em>numtabs=0</em>, <em>spacespertab=4</em>, <em>split=False</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.flattened_docstring" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a docstring with the indentation removed according to the Python standard</p>
<p>split=True returns the output as a list of lines</p>
<p>Changing numtabs adds a custom indentation afterwards</p>
</dd></dl>

<dl class="function">
<dt id="brian.experimental.codegen2.indent_string">
<tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">indent_string</tt><big>(</big><em>s</em>, <em>numtabs=1</em>, <em>spacespertab=4</em>, <em>split=False</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.indent_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Indents a given string or list of lines</p>
<p>split=True returns the output as a list of lines</p>
</dd></dl>

<dl class="function">
<dt id="brian.experimental.codegen2.get_identifiers">
<tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">get_identifiers</tt><big>(</big><em>expr</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.get_identifiers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all the identifiers in a given string <tt class="docutils literal"><span class="pre">expr</span></tt>, that is everything
that matches a programming language variable like expression, which is
here implemented as the regexp <tt class="docutils literal"><span class="pre">\b[A-Za-z_][A-Za-z0-9_]*\b</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="brian.experimental.codegen2.strip_empty_lines">
<tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">strip_empty_lines</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.strip_empty_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all empty lines from the multi-line string <tt class="docutils literal"><span class="pre">s</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="id4">
<h3>gpu<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">GPU code is highly transitional, many details may change in the future.</p>
</div>
<dl class="class">
<dt id="brian.experimental.codegen2.GPUKernel">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">GPUKernel</tt><big>(</big><em>name</em>, <em>code</em>, <em>namespace</em>, <em>mem_man</em>, <em>maxblocksize=512</em>, <em>scalar='double'</em>, <em>force_sync=True</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates final kernel source code and used to launch kernels.</p>
<p>Used in conjunction with <a class="reference internal" href="#brian.experimental.codegen2.GPUManager" title="brian.experimental.codegen2.GPUManager"><tt class="xref py py-class docutils literal"><span class="pre">GPUManager</span></tt></a>. Each kernel is prepared with
<a class="reference internal" href="#brian.experimental.codegen2.GPUKernel.prepare" title="brian.experimental.codegen2.GPUKernel.prepare"><tt class="xref py py-meth docutils literal"><span class="pre">prepare()</span></tt></a> which generates source code and adds symbols to the
<a class="reference internal" href="#brian.experimental.codegen2.GPUSymbolMemoryManager" title="brian.experimental.codegen2.GPUSymbolMemoryManager"><tt class="xref py py-class docutils literal"><span class="pre">GPUSymbolMemoryManager</span></tt></a>. The <a class="reference internal" href="#brian.experimental.codegen2.GPUManager" title="brian.experimental.codegen2.GPUManager"><tt class="xref py py-class docutils literal"><span class="pre">GPUManager</span></tt></a> compiles the
code and sets the <tt class="xref py py-attr docutils literal"><span class="pre">gpu_func</span></tt> attribute, and the kernel can then be
called via <a class="reference internal" href="#brian.experimental.codegen2.GPUKernel.run" title="brian.experimental.codegen2.GPUKernel.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a>.</p>
<p>The initialisation method extracts variable <tt class="docutils literal"><span class="pre">_gpu_vector_index</span></tt> from the
namespace and stores it as attribute <tt class="docutils literal"><span class="pre">index</span></tt>, and <tt class="docutils literal"><span class="pre">_gpu_vector_slice</span></tt>
as the pair <tt class="docutils literal"><span class="pre">(start,</span> <span class="pre">end)</span></tt>.</p>
<dl class="method">
<dt id="brian.experimental.codegen2.GPUKernel.prepare">
<tt class="descname">prepare</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUKernel.prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates kernel source code and adds symbols to memory manager.</p>
<p>We extract the number of GPU indices from the namespace,
<tt class="docutils literal"><span class="pre">_num_gpu_indices</span></tt>.</p>
<p>We loop through the namespace, and for each value determine it to be
either an array or a single value. If it is an array, then we place
it in the <a class="reference internal" href="#brian.experimental.codegen2.GPUSymbolMemoryManager" title="brian.experimental.codegen2.GPUSymbolMemoryManager"><tt class="xref py py-class docutils literal"><span class="pre">GPUSymbolMemoryManager</span></tt></a>, otherwise we add it to the
list of arguments provided to the function call. This allows scalar
variables like <tt class="docutils literal"><span class="pre">t</span></tt> to be transmitted to the kernel function in its
arguments.</p>
<p>We then generate a kernel of the following (Python template) form:</p>
<div class="highlight-python"><pre>__global__ void {name}({funcargs})
{{
    int {vector_index} = blockIdx.x * blockDim.x + threadIdx.x;
    if(({vector_index}&lt;({start}))||({vector_index}&gt;=({end})))
        return;
{code_str}
}}</pre>
</div>
<p>We also compute the block size and grid size using the user provided
maximum block size.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.GPUKernel.prepare_gpu_func">
<tt class="descname">prepare_gpu_func</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUKernel.prepare_gpu_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the <tt class="docutils literal"><span class="pre">pycuda</span></tt> GPU function <tt class="docutils literal"><span class="pre">prepare()</span></tt> method for low-overhead
function calls.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.GPUKernel.run">
<tt class="descname">run</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUKernel.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the function on the GPU, extracting the scalar variables in the
argument list from the namespace.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.GPUManager">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">GPUManager</tt><big>(</big><em>force_sync=True</em>, <em>usefloat=False</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUManager" title="Permalink to this definition">¶</a></dt>
<dd><p>This object controls everything on the GPU.</p>
<p>It uses a <a class="reference internal" href="#brian.experimental.codegen2.GPUKernel" title="brian.experimental.codegen2.GPUKernel"><tt class="xref py py-class docutils literal"><span class="pre">GPUKernel</span></tt></a> object for managing kernels, and a
<a class="reference internal" href="#brian.experimental.codegen2.GPUSymbolMemoryManager" title="brian.experimental.codegen2.GPUSymbolMemoryManager"><tt class="xref py py-class docutils literal"><span class="pre">GPUSymbolMemoryManager</span></tt></a> object for managing symbol memory.</p>
<p>The class is used by:</p>
<ol class="arabic simple">
<li>Adding several kernels using <a class="reference internal" href="#brian.experimental.codegen2.GPUManager.add_kernel" title="brian.experimental.codegen2.GPUManager.add_kernel"><tt class="xref py py-meth docutils literal"><span class="pre">add_kernel()</span></tt></a></li>
<li>Calling <a class="reference internal" href="#brian.experimental.codegen2.GPUManager.prepare" title="brian.experimental.codegen2.GPUManager.prepare"><tt class="xref py py-meth docutils literal"><span class="pre">prepare()</span></tt></a> (see method documentation for details)</li>
<li>Run code with <a class="reference internal" href="#brian.experimental.codegen2.GPUManager.run" title="brian.experimental.codegen2.GPUManager.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a></li>
</ol>
<p>Memory is mirrored on GPU and CPU. In the present implementation, in the
development phase only, each call to <a class="reference internal" href="#brian.experimental.codegen2.GPUManager.run" title="brian.experimental.codegen2.GPUManager.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> will copy all symbols from
CPU to GPU before running the GPU kernel, and afterwards copy all symbols
from GPU back to CPU. In the future, this will be disabled and symbol
memory copies will be handled explicitly by calls to methods
<a class="reference internal" href="#brian.experimental.codegen2.GPUManager.copy_to_device" title="brian.experimental.codegen2.GPUManager.copy_to_device"><tt class="xref py py-meth docutils literal"><span class="pre">copy_to_device()</span></tt></a> and <a class="reference internal" href="#brian.experimental.codegen2.GPUManager.copy_to_host" title="brian.experimental.codegen2.GPUManager.copy_to_host"><tt class="xref py py-meth docutils literal"><span class="pre">copy_to_host()</span></tt></a>.</p>
<dl class="method">
<dt id="brian.experimental.codegen2.GPUManager.add_kernel">
<tt class="descname">add_kernel</tt><big>(</big><em>name</em>, <em>code</em>, <em>namespace</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUManager.add_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a kernel with the given name, code and namespace. Creates a
<a class="reference internal" href="#brian.experimental.codegen2.GPUKernel" title="brian.experimental.codegen2.GPUKernel"><tt class="xref py py-class docutils literal"><span class="pre">GPUKernel</span></tt></a> object.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.GPUManager.add_symbols">
<tt class="descname">add_symbols</tt><big>(</big><em>items</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUManager.add_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Proxy to <a class="reference internal" href="#brian.experimental.codegen2.GPUSymbolMemoryManager.add_symbols" title="brian.experimental.codegen2.GPUSymbolMemoryManager.add_symbols"><tt class="xref py py-meth docutils literal"><span class="pre">GPUSymbolMemoryManager.add_symbols()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.GPUManager.compile">
<tt class="descname">compile</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUManager.compile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiles code using <tt class="xref py py-class docutils literal"><span class="pre">pycuda.compiler.SourceModule</span></tt> and extracts
kernel functions with <tt class="xref py py-meth docutils literal"><span class="pre">pycuda.compiler.SourceModule.get_function()</span></tt>.
The <tt class="xref py py-attr docutils literal"><span class="pre">GPUKernel.gpu_func</span></tt> attribute is set for each kernel.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.GPUManager.copy_to_device">
<tt class="descname">copy_to_device</tt><big>(</big><em>symname</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUManager.copy_to_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Proxy to <a class="reference internal" href="#brian.experimental.codegen2.GPUSymbolMemoryManager.copy_to_device" title="brian.experimental.codegen2.GPUSymbolMemoryManager.copy_to_device"><tt class="xref py py-meth docutils literal"><span class="pre">GPUSymbolMemoryManager.copy_to_device()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.GPUManager.copy_to_host">
<tt class="descname">copy_to_host</tt><big>(</big><em>symname</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUManager.copy_to_host" title="Permalink to this definition">¶</a></dt>
<dd><p>Proxy to <a class="reference internal" href="#brian.experimental.codegen2.GPUSymbolMemoryManager.copy_to_host" title="brian.experimental.codegen2.GPUSymbolMemoryManager.copy_to_host"><tt class="xref py py-meth docutils literal"><span class="pre">GPUSymbolMemoryManager.copy_to_host()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.GPUManager.generate_code">
<tt class="descname">generate_code</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUManager.generate_code" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines kernel source into one source file, and adds memory management
kernel functions. These simple kernels simply copy a pointer to a
previously specified name. This is necessary because when <tt class="docutils literal"><span class="pre">pycuda</span></tt> is
used to allocate memory, it doesn&#8217;t give it a name only a pointer, and
the kernel functions use a named array.</p>
<p>Calls <a class="reference internal" href="#brian.experimental.codegen2.GPUSymbolMemoryManager.generate_code" title="brian.experimental.codegen2.GPUSymbolMemoryManager.generate_code"><tt class="xref py py-meth docutils literal"><span class="pre">GPUSymbolMemoryManager.generate_code()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.GPUManager.initialise_memory">
<tt class="descname">initialise_memory</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUManager.initialise_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies allocated memory pointers to named global memory pointer
variables so that kernels can use them. The kernel names to do this
are in the <tt class="xref py py-attr docutils literal"><span class="pre">GPUSymbolMemoryManager.symbol_upload_funcnames</span></tt>
dict (keys are symbol names), and the allocated pointers are in
the <tt class="xref py py-attr docutils literal"><span class="pre">GPUSymbolMemoryManager.device</span></tt> dict.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.GPUManager.make_combined_kernel">
<tt class="descname">make_combined_kernel</tt><big>(</big><em>*names</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUManager.make_combined_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Not used at present. Will be used to combine multiple kernels with
the same vectorisation index for efficiency.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.GPUManager.prepare">
<tt class="descname">prepare</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUManager.prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiles code and initialises memory.</p>
<p>Performs the following steps:</p>
<ol class="arabic simple">
<li><a class="reference internal" href="#brian.experimental.codegen2.GPUKernel.prepare" title="brian.experimental.codegen2.GPUKernel.prepare"><tt class="xref py py-meth docutils literal"><span class="pre">GPUKernel.prepare()</span></tt></a> is called for each kernel, converting the
partial code into a complete kernel, and adds symbols to the
<a class="reference internal" href="#brian.experimental.codegen2.GPUSymbolMemoryManager" title="brian.experimental.codegen2.GPUSymbolMemoryManager"><tt class="xref py py-class docutils literal"><span class="pre">GPUSymbolMemoryManager</span></tt></a>, which allocates space on the GPU and
copies data to it from the CPU.</li>
<li><a class="reference internal" href="#brian.experimental.codegen2.GPUManager.generate_code" title="brian.experimental.codegen2.GPUManager.generate_code"><tt class="xref py py-meth docutils literal"><span class="pre">generate_code()</span></tt></a> is called, combining individual kernels into
one source file, and adding memory management kernels and
declarations.</li>
<li><a class="reference internal" href="#brian.experimental.codegen2.GPUManager.compile" title="brian.experimental.codegen2.GPUManager.compile"><tt class="xref py py-meth docutils literal"><span class="pre">compile()</span></tt></a> is called, which JIT-compiles the code using
<tt class="docutils literal"><span class="pre">pycuda</span></tt>.</li>
<li><a class="reference internal" href="#brian.experimental.codegen2.GPUManager.initialise_memory" title="brian.experimental.codegen2.GPUManager.initialise_memory"><tt class="xref py py-meth docutils literal"><span class="pre">initialise_memory()</span></tt></a> is called, which allocates memory</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.GPUManager.run">
<tt class="descname">run</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUManager.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the named kernel. Calls <a class="reference internal" href="#brian.experimental.codegen2.GPUKernel.run" title="brian.experimental.codegen2.GPUKernel.run"><tt class="xref py py-meth docutils literal"><span class="pre">GPUKernel.run()</span></tt></a>. Note that all
symbols are copied to and from the GPU before and after the kernel run,
although this is only for the development phase and will change later.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.GPUSymbolMemoryManager">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">GPUSymbolMemoryManager</tt><big>(</big><em>usefloat=False</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUSymbolMemoryManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Manages symbol memory on the GPU.</p>
<p>Stores an attribute <tt class="docutils literal"><span class="pre">device</span></tt> and <tt class="docutils literal"><span class="pre">host</span></tt> which are dicts, with keys the
symbol names, and values <tt class="xref py py-class docutils literal"><span class="pre">pycuda.gpuarray.GPUArray</span></tt> and
<tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt> respectively. Add symbols with <a class="reference internal" href="#brian.experimental.codegen2.GPUSymbolMemoryManager.add_symbols" title="brian.experimental.codegen2.GPUSymbolMemoryManager.add_symbols"><tt class="xref py py-meth docutils literal"><span class="pre">add_symbols()</span></tt></a>,
which will allocate memory.</p>
<dl class="method">
<dt id="brian.experimental.codegen2.GPUSymbolMemoryManager.add_symbols">
<tt class="descname">add_symbols</tt><big>(</big><em>items</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUSymbolMemoryManager.add_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a collection of symbols.</p>
<p>Each item in <tt class="docutils literal"><span class="pre">items</span></tt> is of the form <tt class="docutils literal"><span class="pre">(symname,</span> <span class="pre">hostarr,</span> <span class="pre">devname)</span></tt>
where <tt class="docutils literal"><span class="pre">symname</span></tt> is the symbol name, <tt class="docutils literal"><span class="pre">hostarr</span></tt> is the
<tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt> containing the data, and <tt class="docutils literal"><span class="pre">devname</span></tt> is the name
the array pointer should have on the device.</p>
<p>Allocates memory on the device, and copies data to the GPU.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.GPUSymbolMemoryManager.copy_to_device">
<tt class="descname">copy_to_device</tt><big>(</big><em>symname</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUSymbolMemoryManager.copy_to_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the memory in the <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt> for <tt class="docutils literal"><span class="pre">symname</span></tt> to the
allocated device memory. If <tt class="docutils literal"><span class="pre">symname==True</span></tt>, do this for all symbols.
You can also pass a list for <tt class="docutils literal"><span class="pre">symname</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.GPUSymbolMemoryManager.copy_to_host">
<tt class="descname">copy_to_host</tt><big>(</big><em>symname</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUSymbolMemoryManager.copy_to_host" title="Permalink to this definition">¶</a></dt>
<dd><p>As for <a class="reference internal" href="#brian.experimental.codegen2.GPUSymbolMemoryManager.copy_to_device" title="brian.experimental.codegen2.GPUSymbolMemoryManager.copy_to_device"><tt class="xref py py-meth docutils literal"><span class="pre">copy_to_device()</span></tt></a> but copies memory from device to host.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.GPUSymbolMemoryManager.generate_code">
<tt class="descname">generate_code</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUSymbolMemoryManager.generate_code" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates declarations for array pointer names on the device, and
kernels to copy device pointers to the array pointers. General form
is:</p>
<div class="highlight-python"><pre>__device__ {dtypestr} *{name};
__global__ void set_array_{name}({dtypestr} *_{name})
{
    {name} = _{name};
}</pre>
</div>
<p>Stores the kernel function names in attribute
<tt class="xref py py-attr docutils literal"><span class="pre">symbol_upload_funcnames</span></tt> (dict with keys being symbol names).</p>
<p>Returns a string with declarations and kernels combined.</p>
</dd></dl>

<dl class="attribute">
<dt id="brian.experimental.codegen2.GPUSymbolMemoryManager.names">
<tt class="descname">names</tt><a class="headerlink" href="#brian.experimental.codegen2.GPUSymbolMemoryManager.names" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of symbol names managed.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.GPUCode">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">GPUCode</tt><big>(</big><em>name</em>, <em>code_str</em>, <em>namespace</em>, <em>pre_code=None</em>, <em>post_code=None</em>, <em>language=None</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUCode" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#brian.experimental.codegen2.Code" title="brian.experimental.codegen2.Code"><tt class="xref py py-class docutils literal"><span class="pre">Code</span></tt></a> object for GPU.</p>
<p>For the user, works as the same as any other <a class="reference internal" href="#brian.experimental.codegen2.Code" title="brian.experimental.codegen2.Code"><tt class="xref py py-class docutils literal"><span class="pre">Code</span></tt></a> object. Behind
the scenes, source code is passed to the <a class="reference internal" href="#brian.experimental.codegen2.GPUManager" title="brian.experimental.codegen2.GPUManager"><tt class="xref py py-class docutils literal"><span class="pre">GPUManager</span></tt></a> <tt class="docutils literal"><span class="pre">gpu_man</span></tt>
from the <a class="reference internal" href="#brian.experimental.codegen2.GPULanguage" title="brian.experimental.codegen2.GPULanguage"><tt class="xref py py-class docutils literal"><span class="pre">GPULanguage</span></tt></a> object, via <a class="reference internal" href="#brian.experimental.codegen2.GPUManager.add_kernel" title="brian.experimental.codegen2.GPUManager.add_kernel"><tt class="xref py py-meth docutils literal"><span class="pre">GPUManager.add_kernel()</span></tt></a>.
Compilation is handled by <a class="reference internal" href="#brian.experimental.codegen2.GPUManager.prepare" title="brian.experimental.codegen2.GPUManager.prepare"><tt class="xref py py-meth docutils literal"><span class="pre">GPUManager.prepare()</span></tt></a>, and running code
by <a class="reference internal" href="#brian.experimental.codegen2.GPUManager.run" title="brian.experimental.codegen2.GPUManager.run"><tt class="xref py py-meth docutils literal"><span class="pre">GPUManager.run()</span></tt></a>.</p>
<dl class="method">
<dt id="brian.experimental.codegen2.GPUCode.compile">
<tt class="descname">compile</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUCode.compile" title="Permalink to this definition">¶</a></dt>
<dd><p>Simply calls <a class="reference internal" href="#brian.experimental.codegen2.GPUManager.prepare" title="brian.experimental.codegen2.GPUManager.prepare"><tt class="xref py py-meth docutils literal"><span class="pre">GPUManager.prepare()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.GPUCode.run">
<tt class="descname">run</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPUCode.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Simply runs the kernel via <a class="reference internal" href="#brian.experimental.codegen2.GPUManager.run" title="brian.experimental.codegen2.GPUManager.run"><tt class="xref py py-meth docutils literal"><span class="pre">GPUManager.run()</span></tt></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.GPULanguage">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">GPULanguage</tt><big>(</big><em>scalar='double'</em>, <em>gpu_man=None</em>, <em>force_sync=True</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.GPULanguage" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#brian.experimental.codegen2.Language" title="brian.experimental.codegen2.Language"><tt class="xref py py-class docutils literal"><span class="pre">Language</span></tt></a> object for GPU.</p>
<p>Has an attribute <tt class="docutils literal"><span class="pre">gpu_man</span></tt>, the <a class="reference internal" href="#brian.experimental.codegen2.GPUManager" title="brian.experimental.codegen2.GPUManager"><tt class="xref py py-class docutils literal"><span class="pre">GPUManager</span></tt></a> object responsible for
allocating, copying memory, etc. One is created if you do not specify one.</p>
<dl class="attribute">
<dt id="brian.experimental.codegen2.GPULanguage.CodeObjectClass">
<tt class="descname">CodeObjectClass</tt><a class="headerlink" href="#brian.experimental.codegen2.GPULanguage.CodeObjectClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#brian.experimental.codegen2.GPUCode" title="brian.experimental.codegen2.GPUCode"><tt class="xref py py-class docutils literal"><span class="pre">GPUCode</span></tt></a></p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id5">
<h3>integration<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="brian.experimental.codegen2.EquationsContainer">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">EquationsContainer</tt><big>(</big><em>eqs</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.EquationsContainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility class for defining numerical integration scheme</p>
<p>Initialise with a set of equations <tt class="docutils literal"><span class="pre">eqs</span></tt>. You can now iterate over
this object in two ways, firstly over all the differential equations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">eqscontainer</span><span class="p">:</span>
    <span class="k">yield</span> <span class="n">f</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
</pre></div>
</div>
<p>Or over just the differential equations with nonzero expressions (i.e.
not including <tt class="docutils literal"><span class="pre">dx/dt=0</span></tt> for parameters):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">eqscontainer</span><span class="o">.</span><span class="n">nonzero</span><span class="p">:</span>
    <span class="k">yield</span> <span class="n">f</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">var</span></tt> is the name of the symbol, and <tt class="docutils literal"><span class="pre">expr</span></tt> is a string, the
right hand side of the differential equation <tt class="docutils literal"><span class="pre">dvar/dt=expr</span></tt>.</p>
<p>Also has attributes:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">names</span></tt></dt>
<dd>The symbol names for all the differential equations</dd>
<dt><tt class="docutils literal"><span class="pre">names_nonzero</span></tt></dt>
<dd>The symbol names for all the nonzero differential equations</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="brian.experimental.codegen2.make_integration_step">
<tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">make_integration_step</tt><big>(</big><em>method</em>, <em>eqs</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.make_integration_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an integration step from a method and a set of equations.</p>
<p>The <tt class="docutils literal"><span class="pre">method</span></tt> should be a function <tt class="docutils literal"><span class="pre">method(eqs)</span></tt> which receives a
<a class="reference internal" href="#brian.experimental.codegen2.EquationsContainer" title="brian.experimental.codegen2.EquationsContainer"><tt class="xref py py-class docutils literal"><span class="pre">EquationsContainer</span></tt></a> object as its argument, and <tt class="docutils literal"><span class="pre">yield</span></tt> s
statements. For example, the <a class="reference internal" href="#brian.experimental.codegen2.euler" title="brian.experimental.codegen2.euler"><tt class="xref py py-func docutils literal"><span class="pre">euler()</span></tt></a> integration step is defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">euler</span><span class="p">(</span><span class="n">eqs</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">eqs</span><span class="o">.</span><span class="n">nonzero</span><span class="p">:</span>
        <span class="k">yield</span> <span class="s">&#39;_temp_{var} := {expr}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">var</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">eqs</span><span class="o">.</span><span class="n">nonzero</span><span class="p">:</span>
        <span class="k">yield</span> <span class="s">&#39;{var} += _temp_{var}*dt&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">var</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">expr</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brian.experimental.codegen2.euler">
<tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">euler</tt><big>(</big><em>eqs</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.euler" title="Permalink to this definition">¶</a></dt>
<dd><p>Euler integration</p>
</dd></dl>

<dl class="function">
<dt id="brian.experimental.codegen2.rk2">
<tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">rk2</tt><big>(</big><em>eqs</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.rk2" title="Permalink to this definition">¶</a></dt>
<dd><p>2nd order Runge-Kutta integration</p>
</dd></dl>

<dl class="function">
<dt id="brian.experimental.codegen2.exp_euler">
<tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">exp_euler</tt><big>(</big><em>eqs</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.exp_euler" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential-Euler integration</p>
</dd></dl>

</div>
<div class="section" id="id6">
<h3>languages<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="brian.experimental.codegen2.Language">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">Language</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Language" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for languages, each should provide a <tt class="docutils literal"><span class="pre">name</span></tt> attribute, and a
method <a class="reference internal" href="#brian.experimental.codegen2.Language.code_object" title="brian.experimental.codegen2.Language.code_object"><tt class="xref py py-meth docutils literal"><span class="pre">code_object()</span></tt></a>.</p>
<dl class="method">
<dt id="brian.experimental.codegen2.Language.code_object">
<tt class="descname">code_object</tt><big>(</big><em>name</em>, <em>code_str</em>, <em>namespace</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Language.code_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference internal" href="#brian.experimental.codegen2.Code" title="brian.experimental.codegen2.Code"><tt class="xref py py-class docutils literal"><span class="pre">Code</span></tt></a> object from a given <tt class="docutils literal"><span class="pre">name</span></tt>, code string
<tt class="docutils literal"><span class="pre">code_str</span></tt> and <tt class="docutils literal"><span class="pre">namespace</span></tt>. If the class has a class attribute
<tt class="docutils literal"><span class="pre">CodeObjectClass</span></tt>, the default implementation returns:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CodeObjectClass</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">code_str</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="n">language</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.PythonLanguage">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">PythonLanguage</tt><a class="headerlink" href="#brian.experimental.codegen2.PythonLanguage" title="Permalink to this definition">¶</a></dt>
<dd><p>Python language.</p>
<dl class="attribute">
<dt id="brian.experimental.codegen2.PythonLanguage.CodeObjectClass">
<tt class="descname">CodeObjectClass</tt><a class="headerlink" href="#brian.experimental.codegen2.PythonLanguage.CodeObjectClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#brian.experimental.codegen2.PythonCode" title="brian.experimental.codegen2.PythonCode"><tt class="xref py py-class docutils literal"><span class="pre">PythonCode</span></tt></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.CLanguage">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">CLanguage</tt><big>(</big><em>scalar='double'</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.CLanguage" title="Permalink to this definition">¶</a></dt>
<dd><p>C language.</p>
<p>Has an attribute <tt class="docutils literal"><span class="pre">scalar='double'</span></tt> which gives the default type of
scalar values (used when <tt class="docutils literal"><span class="pre">dtype</span></tt> is not specified). This can be used, for
example, on the GPU where <tt class="docutils literal"><span class="pre">double</span></tt> may not be available.</p>
<dl class="attribute">
<dt id="brian.experimental.codegen2.CLanguage.CodeObjectClass">
<tt class="descname">CodeObjectClass</tt><a class="headerlink" href="#brian.experimental.codegen2.CLanguage.CodeObjectClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#brian.experimental.codegen2.CCode" title="brian.experimental.codegen2.CCode"><tt class="xref py py-class docutils literal"><span class="pre">CCode</span></tt></a></p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="makeintegrator">
<h3>makeintegrator<a class="headerlink" href="#makeintegrator" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="brian.experimental.codegen2.make_c_integrator">
<tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">make_c_integrator</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.make_c_integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives C/C++ format code for the integration step of a differential equation.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">eqs</span></tt></dt>
<dd>The equations, can be an <a class="reference internal" href="reference-models-and-groups.html#brian.Equations" title="brian.Equations"><tt class="xref py py-class docutils literal"><span class="pre">brian.Equations</span></tt></a> object or a multiline
string in Brian equations format.</dd>
<dt><tt class="docutils literal"><span class="pre">method</span></tt></dt>
<dd>The integration method, typically <a class="reference internal" href="#brian.experimental.codegen2.euler" title="brian.experimental.codegen2.euler"><tt class="xref py py-func docutils literal"><span class="pre">euler()</span></tt></a>, <a class="reference internal" href="#brian.experimental.codegen2.rk2" title="brian.experimental.codegen2.rk2"><tt class="xref py py-func docutils literal"><span class="pre">rk2()</span></tt></a> or
<a class="reference internal" href="#brian.experimental.codegen2.exp_euler" title="brian.experimental.codegen2.exp_euler"><tt class="xref py py-func docutils literal"><span class="pre">exp_euler()</span></tt></a>, although you can pass your own integration method,
see <a class="reference internal" href="#brian.experimental.codegen2.make_integration_step" title="brian.experimental.codegen2.make_integration_step"><tt class="xref py py-func docutils literal"><span class="pre">make_integration_step()</span></tt></a> for details.</dd>
<dt><tt class="docutils literal"><span class="pre">dt</span></tt></dt>
<dd>The value of the timestep dt (in Brian units, e.g. <tt class="docutils literal"><span class="pre">0.1*ms</span></tt>)</dd>
<dt><tt class="docutils literal"><span class="pre">values</span></tt></dt>
<dd>Optional, dictionary of mappings variable-&gt;value, these values will
be inserted into the generated code.</dd>
<dt><tt class="docutils literal"><span class="pre">scalar</span></tt></dt>
<dd>By default it is <tt class="docutils literal"><span class="pre">'double'</span></tt> but if you want to use float as your
scalar type, set this to <tt class="docutils literal"><span class="pre">'float'</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">timename</span></tt></dt>
<dd>The name of the time variable (if used). In Brian this is &#8216;t&#8217;, but
you can change it to &#8216;T&#8217; or &#8216;time&#8217; or whatever. This can be used if you
want users to specify time in Brian form (&#8216;t&#8217;) but the context in which
this code will be used (e.g. another simulator) specifies time with a
different variable name (e.g. &#8216;T&#8217;).</dd>
<dt><tt class="docutils literal"><span class="pre">timeunit</span></tt></dt>
<dd>The unit of the time variable, scaled because Brian expects time to be
in seconds.</dd>
</dl>
<p>Returns a triple <tt class="docutils literal"><span class="pre">(code,</span> <span class="pre">vars,</span> <span class="pre">params)</span></tt>:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">code</span></tt></dt>
<dd>The C/C++ code to perform the update step (string).</dd>
<dt><tt class="docutils literal"><span class="pre">vars</span></tt></dt>
<dd>A list of variable names.</dd>
<dt><tt class="docutils literal"><span class="pre">params</span></tt></dt>
<dd>A list of per-neuron parameter names.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="id7">
<h3>reset<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="brian.experimental.codegen2.CodeGenReset">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">CodeGenReset</tt><big>(</big><em>group</em>, <em>inputcode</em>, <em>language</em>, <em>level=0</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.CodeGenReset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="resolution">
<h3>resolution<a class="headerlink" href="#resolution" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="brian.experimental.codegen2.resolve">
<tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">resolve</tt><big>(</big><em>item</em>, <em>symbols</em>, <em>namespace=None</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.resolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolves <tt class="docutils literal"><span class="pre">symbols</span></tt> in <tt class="docutils literal"><span class="pre">item</span></tt> in the optimal order.</p>
<p>The first stage of this algorithm is to construct a dependency graph
on the symbols.</p>
<p>The optimal order is resolve loops as late as possible.
We actually construct the inverse of the resolution order, which is the
intuitive order (i.e. if the first thing we do is loop over a variable, then
that variable is the last symbol we resolve).</p>
<p>We start by
finding the set of symbols which have no dependencies. The graph is
acyclic so this always possible. Then, among those candidates, if possible
we choose loopless symbols first (this corresponds to executing loops as
late as possible). With this symbol removed from the graph we repeat until
all symbols are placed in order.</p>
<p>We then resolve in reverse order (because we start with the inner loop
and add code outwards). At the beginning of this stage, vectorisable is
set to <tt class="docutils literal"><span class="pre">True</span></tt>. But after we encounter the first multi-valued symbol
we set <tt class="docutils literal"><span class="pre">vectorisable</span></tt> to <tt class="docutils literal"><span class="pre">False</span></tt> (we can only vectorise one loop, and
it has to be the innermost one). This vectorisation is used by both Python
and GPU but not C++. Each resolution step calls <tt class="xref py py-meth docutils literal"><span class="pre">CodeItem.resolve()</span></tt> on
the output of the previous stage.</p>
</dd></dl>

</div>
<div class="section" id="statements">
<h3>statements<a class="headerlink" href="#statements" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="brian.experimental.codegen2.Statement">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">Statement</tt><a class="headerlink" href="#brian.experimental.codegen2.Statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Just a base class, supposed to indicate single line statements.</p>
</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.CodeStatement">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">CodeStatement</tt><big>(</big><em>code</em>, <em>dependencies</em>, <em>resolved</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.CodeStatement" title="Permalink to this definition">¶</a></dt>
<dd><p>A language-specific single line of code, which should only be used in
the resolution step by a <a class="reference internal" href="#brian.experimental.codegen2.Symbol" title="brian.experimental.codegen2.Symbol"><tt class="xref py py-class docutils literal"><span class="pre">Symbol</span></tt></a> which knows the language it is
resolving to. The string <tt class="docutils literal"><span class="pre">code</span></tt> and the set of <tt class="docutils literal"><span class="pre">dependencies</span></tt> and
<tt class="docutils literal"><span class="pre">resolved</span></tt> have to be given explicitly.</p>
<dl class="method">
<dt id="brian.experimental.codegen2.CodeStatement.convert_to">
<tt class="descname">convert_to</tt><big>(</big><em>language</em>, <em>symbols={}</em>, <em>namespace={}</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.CodeStatement.convert_to" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.CDefineFromArray">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">CDefineFromArray</tt><big>(</big><em>var</em>, <em>arr</em>, <em>index</em>, <em>dependencies=None</em>, <em>resolved=None</em>, <em>dtype=None</em>, <em>reference=True</em>, <em>const=False</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.CDefineFromArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a variable from an array and an index in C.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">double</span> <span class="o">&amp;</span><span class="n">V</span> <span class="o">=</span> <span class="n">__arr_V</span><span class="p">[</span><span class="n">neuron_index</span><span class="p">];</span>
</pre></div>
</div>
<p>Initialisation arguments are:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">var</span></tt></dt>
<dd>The variable being defined, a string.</dd>
<dt><tt class="docutils literal"><span class="pre">arr</span></tt></dt>
<dd>A string representing the array.</dd>
<dt><tt class="docutils literal"><span class="pre">index</span></tt></dt>
<dd>A string giving the index.</dd>
<dt><tt class="docutils literal"><span class="pre">dependencies</span></tt></dt>
<dd>Given explicitly, or by default use <tt class="docutils literal"><span class="pre">set([Read(arr),</span> <span class="pre">Read(index)])</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">resolved</span></tt></dt>
<dd>Given explicitly, or by default use <tt class="docutils literal"><span class="pre">set([var])</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">dtype</span></tt></dt>
<dd>The numpy data type of the variable being defined.</dd>
<dt><tt class="docutils literal"><span class="pre">reference</span></tt></dt>
<dd>Whether the variable should be treated as a C++ reference (e.g.
<tt class="docutils literal"><span class="pre">double</span> <span class="pre">&amp;V</span> <span class="pre">=</span> <span class="pre">...</span></tt> rather than <tt class="docutils literal"><span class="pre">double</span> <span class="pre">V</span> <span class="pre">=</span> <span class="pre">...</span></tt>. If the variable
is being written to as well as read from, use <tt class="docutils literal"><span class="pre">reference=True</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">const</span></tt></dt>
<dd>Whether the variable can be defined as const, specify this if only
reading the value and not writing to it.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.MathematicalStatement">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">MathematicalStatement</tt><big>(</big><em>var</em>, <em>op</em>, <em>expr</em>, <em>dtype=None</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.MathematicalStatement" title="Permalink to this definition">¶</a></dt>
<dd><p>A single line mathematical statement.</p>
<p>The structure is <tt class="docutils literal"><span class="pre">var</span> <span class="pre">op</span> <span class="pre">expr</span></tt>.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">var</span></tt></dt>
<dd>The left hand side of the statement, the value being written to, a
string.</dd>
<dt><tt class="docutils literal"><span class="pre">op</span></tt></dt>
<dd>The operation, can be any of the standard Python operators (including
<tt class="docutils literal"><span class="pre">+=</span></tt> etc.) or a special operator <tt class="docutils literal"><span class="pre">:=</span></tt> which means you are defining
a new symbol (whereas <tt class="docutils literal"><span class="pre">=</span></tt> means you are setting the value of an
existing symbol).</dd>
<dt><tt class="docutils literal"><span class="pre">expr</span></tt></dt>
<dd>A string or an <a class="reference internal" href="#brian.experimental.codegen2.Expression" title="brian.experimental.codegen2.Expression"><tt class="xref py py-class docutils literal"><span class="pre">Expression</span></tt></a> object, giving the right hand side
of the statement.</dd>
<dt><tt class="docutils literal"><span class="pre">dtype</span></tt></dt>
<dd>If you are defining a new variable, you need to specify its numpy dtype.</dd>
</dl>
<p>If <tt class="docutils literal"><span class="pre">op==':='</span></tt> then this statement will resolve <tt class="docutils literal"><span class="pre">var</span></tt>, otherwise it will
add a <a class="reference internal" href="#brian.experimental.codegen2.Write" title="brian.experimental.codegen2.Write"><tt class="xref py py-class docutils literal"><span class="pre">Write</span></tt></a> dependency for <tt class="docutils literal"><span class="pre">var</span></tt>. The other dependencies come
from <tt class="docutils literal"><span class="pre">expr</span></tt>.</p>
<dl class="method">
<dt id="brian.experimental.codegen2.MathematicalStatement.convert_to">
<tt class="descname">convert_to</tt><big>(</big><em>language</em>, <em>symbols={}</em>, <em>tabs=0</em>, <em>namespace={}</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.MathematicalStatement.convert_to" title="Permalink to this definition">¶</a></dt>
<dd><p>When converting to a code string, the following takes place:</p>
<ul class="simple">
<li>If the LHS variable is in the set of <tt class="docutils literal"><span class="pre">symbols</span></tt>, then the LHS
is replaced by <tt class="docutils literal"><span class="pre">sym.write()</span></tt></li>
<li>The expression is converted with <a class="reference internal" href="#brian.experimental.codegen2.Expression.convert_to" title="brian.experimental.codegen2.Expression.convert_to"><tt class="xref py py-meth docutils literal"><span class="pre">Expression.convert_to()</span></tt></a>.</li>
<li>If the operation is definition <tt class="docutils literal"><span class="pre">op==':='</span></tt> then the output is
language dependent. For Python it is <tt class="docutils literal"><span class="pre">lhs</span> <span class="pre">=</span> <span class="pre">rhs</span></tt> and for C or
GPU it is <tt class="docutils literal"><span class="pre">dtype</span> <span class="pre">lhs</span> <span class="pre">=</span> <span class="pre">rhs</span></tt>.</li>
<li>If the operation is not definition, the statement is converted to
<tt class="docutils literal"><span class="pre">lhs</span> <span class="pre">op</span> <span class="pre">rhs</span></tt>.</li>
<li>If the language is C/GPU the statement has <tt class="docutils literal"><span class="pre">;</span></tt> appended.</li>
</ul>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="brian.experimental.codegen2.statements_from_codestring">
<tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">statements_from_codestring</tt><big>(</big><em>code</em>, <em>eqs=None</em>, <em>defined=None</em>, <em>infer_definitions=False</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.statements_from_codestring" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a list of statements from a user-defined string.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">code</span></tt></dt>
<dd>The input code string, a multi-line string which should be flat, no
indents.</dd>
<dt><tt class="docutils literal"><span class="pre">eqs</span></tt></dt>
<dd>A Brian <a class="reference internal" href="reference-models-and-groups.html#brian.Equations" title="brian.Equations"><tt class="xref py py-class docutils literal"><span class="pre">Equations</span></tt></a> object, which is used to specify
a set of already defined variable names if you are using
<tt class="docutils literal"><span class="pre">infer_definitions</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">defined</span></tt></dt>
<dd>A set of symbol names which are already defined, if you are using
<tt class="docutils literal"><span class="pre">infer_definitions</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">infer_definitions</span></tt></dt>
<dd>Set to <tt class="docutils literal"><span class="pre">True</span></tt> to guess when a line of the form <tt class="docutils literal"><span class="pre">a=b</span></tt> should be
inferred to be of type <tt class="docutils literal"><span class="pre">a:=b</span></tt>, as user-specified code may not make
the distinction between <tt class="docutils literal"><span class="pre">a=b</span></tt> and <tt class="docutils literal"><span class="pre">a:=b</span></tt>.</dd>
</dl>
<p>The rule for definition inference is that you scan through the lines, and
a set of already defined symbols is maintained (starting from <tt class="docutils literal"><span class="pre">eqs</span></tt> and
<tt class="docutils literal"><span class="pre">defined</span></tt> if provided), and an <tt class="docutils literal"><span class="pre">=</span></tt> op is changed to <tt class="docutils literal"><span class="pre">:=</span></tt> if the
name on the LHS is not already in the set of symbols already defined.</p>
</dd></dl>

<dl class="function">
<dt id="brian.experimental.codegen2.c_data_type">
<tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">c_data_type</tt><big>(</big><em>dtype</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.c_data_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the C language specifier for numpy data types. For example,
<tt class="docutils literal"><span class="pre">numpy.int32</span></tt> maps to <tt class="docutils literal"><span class="pre">int32_t</span></tt> in C.</p>
<p>Perhaps this method is given somewhere in numpy, but I couldn&#8217;t find it.</p>
</dd></dl>

</div>
<div class="section" id="stateupdater">
<h3>stateupdater<a class="headerlink" href="#stateupdater" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="brian.experimental.codegen2.CodeGenStateUpdater">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">CodeGenStateUpdater</tt><big>(</big><em>group</em>, <em>method</em>, <em>language</em>, <em>clock=None</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.CodeGenStateUpdater" title="Permalink to this definition">¶</a></dt>
<dd><p>State updater using code generation, supports Python, C++, GPU.</p>
<p>Initialised with:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">group</span></tt></dt>
<dd>The <a class="reference internal" href="reference-models-and-groups.html#brian.NeuronGroup" title="brian.NeuronGroup"><tt class="xref py py-class docutils literal"><span class="pre">NeuronGroup</span></tt></a> that this will be used in.</dd>
<dt><tt class="docutils literal"><span class="pre">method</span></tt></dt>
<dd>The integration method, currently one of <a class="reference internal" href="#brian.experimental.codegen2.euler" title="brian.experimental.codegen2.euler"><tt class="xref py py-func docutils literal"><span class="pre">euler()</span></tt></a>, <a class="reference internal" href="#brian.experimental.codegen2.rk2" title="brian.experimental.codegen2.rk2"><tt class="xref py py-func docutils literal"><span class="pre">rk2()</span></tt></a>
or <a class="reference internal" href="#brian.experimental.codegen2.exp_euler" title="brian.experimental.codegen2.exp_euler"><tt class="xref py py-func docutils literal"><span class="pre">exp_euler()</span></tt></a>, but you can define your own too. See
<a class="reference internal" href="#brian.experimental.codegen2.make_integration_step" title="brian.experimental.codegen2.make_integration_step"><tt class="xref py py-func docutils literal"><span class="pre">make_integration_step()</span></tt></a> for details.</dd>
<dt><tt class="docutils literal"><span class="pre">language</span></tt></dt>
<dd>The <a class="reference internal" href="#brian.experimental.codegen2.Language" title="brian.experimental.codegen2.Language"><tt class="xref py py-class docutils literal"><span class="pre">Language</span></tt></a> object.</dd>
</dl>
<p>Creates a <a class="reference internal" href="#brian.experimental.codegen2.Block" title="brian.experimental.codegen2.Block"><tt class="xref py py-class docutils literal"><span class="pre">Block</span></tt></a> from the equations and the <tt class="docutils literal"><span class="pre">method</span></tt>, gets a set
of <a class="reference internal" href="#brian.experimental.codegen2.Symbol" title="brian.experimental.codegen2.Symbol"><tt class="xref py py-class docutils literal"><span class="pre">Symbol</span></tt></a> objects from <a class="reference internal" href="#brian.experimental.codegen2.get_neuron_group_symbols" title="brian.experimental.codegen2.get_neuron_group_symbols"><tt class="xref py py-func docutils literal"><span class="pre">get_neuron_group_symbols()</span></tt></a>, and
defines the symbol <tt class="docutils literal"><span class="pre">_neuron_index</span></tt> as a <a class="reference internal" href="#brian.experimental.codegen2.SliceIndex" title="brian.experimental.codegen2.SliceIndex"><tt class="xref py py-class docutils literal"><span class="pre">SliceIndex</span></tt></a>. Then calls
<a class="reference internal" href="#brian.experimental.codegen2.CodeItem.generate" title="brian.experimental.codegen2.CodeItem.generate"><tt class="xref py py-meth docutils literal"><span class="pre">CodeItem.generate()</span></tt></a> to get the <a class="reference internal" href="#brian.experimental.codegen2.Code" title="brian.experimental.codegen2.Code"><tt class="xref py py-class docutils literal"><span class="pre">Code</span></tt></a> object.</p>
<p>Inserts <tt class="docutils literal"><span class="pre">t</span></tt> and <tt class="docutils literal"><span class="pre">dt</span></tt> into the namespace, and <tt class="docutils literal"><span class="pre">_num_neurons</span></tt> and
<tt class="docutils literal"><span class="pre">_num_gpu_indices</span></tt> in case they are needed.</p>
</dd></dl>

</div>
<div class="section" id="id8">
<h3>symbols<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="brian.experimental.codegen2.Symbol">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">Symbol</tt><big>(</big><em>name</em>, <em>language</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all symbols.</p>
<p>Every symbol has attributes <tt class="docutils literal"><span class="pre">name</span></tt> and <tt class="docutils literal"><span class="pre">language</span></tt> which should be a
string and <a class="reference internal" href="#brian.experimental.codegen2.Language" title="brian.experimental.codegen2.Language"><tt class="xref py py-class docutils literal"><span class="pre">Language</span></tt></a> object respectively. The symbol class should
define some or all of the methods below.</p>
<dl class="method">
<dt id="brian.experimental.codegen2.Symbol.dependencies">
<tt class="descname">dependencies</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Symbol.dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set of dependencies of this symbol, can be overridden.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.Symbol.load">
<tt class="descname">load</tt><big>(</big><em>read</em>, <em>write</em>, <em>vectorisable</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Symbol.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Called by <a class="reference internal" href="#brian.experimental.codegen2.resolve" title="brian.experimental.codegen2.resolve"><tt class="xref py py-meth docutils literal"><span class="pre">resolve()</span></tt></a>, can be overridden to perform more complicated
loading code. By default, returns an empty <a class="reference internal" href="#brian.experimental.codegen2.Block" title="brian.experimental.codegen2.Block"><tt class="xref py py-class docutils literal"><span class="pre">Block</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.Symbol.multi_valued">
<tt class="descname">multi_valued</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Symbol.multi_valued" title="Permalink to this definition">¶</a></dt>
<dd><p>Should return <tt class="docutils literal"><span class="pre">True</span></tt> if this symbol is considered to have multiple
values, for example if you are iterating over an array like so:</p>
<div class="highlight-python"><pre>for(int i=0; i&lt;n; i++)
{
    double &amp;x = arr[i];
    ...
}</pre>
</div>
<p>Here the symbol <tt class="docutils literal"><span class="pre">x</span></tt> is single-valued and depends on the symbol <tt class="docutils literal"><span class="pre">i</span></tt>
which is multi-valued and whose resolution required a loop. By default
returns <tt class="docutils literal"><span class="pre">False</span></tt> unless the class has an attribute <tt class="docutils literal"><span class="pre">multiple_values</span></tt>
in which case this is returned.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.Symbol.read">
<tt class="descname">read</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Symbol.read" title="Permalink to this definition">¶</a></dt>
<dd><p>The string that should be used when this symbol is read, by default
just the symbol name.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.Symbol.resolution_requires_loop">
<tt class="descname">resolution_requires_loop</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Symbol.resolution_requires_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Should return <tt class="docutils literal"><span class="pre">True</span></tt> if the resolution of this symbol will require a
loop. The <a class="reference internal" href="#brian.experimental.codegen2.resolve" title="brian.experimental.codegen2.resolve"><tt class="xref py py-func docutils literal"><span class="pre">resolve()</span></tt></a> function uses this to optimise the symbol
resolution order.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.Symbol.resolve">
<tt class="descname">resolve</tt><big>(</big><em>read</em>, <em>write</em>, <em>vectorisable</em>, <em>item</em>, <em>namespace</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Symbol.resolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a modified item in which the symbol has been resolved.</p>
<p>For example, if we started from the expression:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>and we wanted to produce the following C++ code:</p>
<div class="highlight-python"><pre>for(int i=0; i&lt;n; i++)
{
    double &amp;x = __arr_x[i];
    x += 1;
}</pre>
</div>
<p>we would need to take the expression <tt class="docutils literal"><span class="pre">x+=1</span></tt> and embed it inside a
loop.</p>
<p>Function arguments:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">read</span></tt></dt>
<dd>Whether or not we read the value of the symbol. This is computed
by analysing the dependencies by the main <a class="reference internal" href="#brian.experimental.codegen2.resolve" title="brian.experimental.codegen2.resolve"><tt class="xref py py-func docutils literal"><span class="pre">resolve()</span></tt></a> function.</dd>
<dt><tt class="docutils literal"><span class="pre">write</span></tt></dt>
<dd>Whether or not we write a value to the symbol.</dd>
<dt><tt class="docutils literal"><span class="pre">vectorisable</span></tt></dt>
<dd>Whether or not the expression is vectorisable. In Python, we can
only vectorise one multi-valued index, so if there are two or more,
only the innermost loop will be vectorised.</dd>
<dt><tt class="docutils literal"><span class="pre">item</span></tt></dt>
<dd>The code item which needs to be resolved.</dd>
<dt><tt class="docutils literal"><span class="pre">namespace</span></tt></dt>
<dd>The namespace to put data in.</dd>
</dl>
<p>The default implementation first calls <a class="reference internal" href="#brian.experimental.codegen2.Symbol.update_namespace" title="brian.experimental.codegen2.Symbol.update_namespace"><tt class="xref py py-meth docutils literal"><span class="pre">update_namespace()</span></tt></a>, then
creates a new <a class="reference internal" href="#brian.experimental.codegen2.Block" title="brian.experimental.codegen2.Block"><tt class="xref py py-class docutils literal"><span class="pre">Block</span></tt></a> consisting of the value returned by
<a class="reference internal" href="#brian.experimental.codegen2.Symbol.load" title="brian.experimental.codegen2.Symbol.load"><tt class="xref py py-meth docutils literal"><span class="pre">load()</span></tt></a>, the <tt class="docutils literal"><span class="pre">item</span></tt>, and the value returned by <a class="reference internal" href="#brian.experimental.codegen2.Symbol.save" title="brian.experimental.codegen2.Symbol.save"><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></a>.
Finally, this symbol&#8217;s name is added to the <tt class="docutils literal"><span class="pre">resolved</span></tt> set for this
block.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.Symbol.save">
<tt class="descname">save</tt><big>(</big><em>read</em>, <em>write</em>, <em>vectorisable</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Symbol.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Called by <a class="reference internal" href="#brian.experimental.codegen2.resolve" title="brian.experimental.codegen2.resolve"><tt class="xref py py-meth docutils literal"><span class="pre">resolve()</span></tt></a>, can be overridden to perform more complicated
saving code. By default, returns an empty <a class="reference internal" href="#brian.experimental.codegen2.Block" title="brian.experimental.codegen2.Block"><tt class="xref py py-class docutils literal"><span class="pre">Block</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.Symbol.supported">
<tt class="descname">supported</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Symbol.supported" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if the language specified at initialisation is
supported. By default, checks if the language name is in the class
attribute <tt class="docutils literal"><span class="pre">supported_languages</span></tt> (list), however can be overridden.</p>
</dd></dl>

<dl class="attribute">
<dt id="brian.experimental.codegen2.Symbol.supported_languages">
<tt class="descname">supported_languages</tt><em class="property"> = []</em><a class="headerlink" href="#brian.experimental.codegen2.Symbol.supported_languages" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.Symbol.update_namespace">
<tt class="descname">update_namespace</tt><big>(</big><em>read</em>, <em>write</em>, <em>vectorisable</em>, <em>namespace</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Symbol.update_namespace" title="Permalink to this definition">¶</a></dt>
<dd><p>Called by <a class="reference internal" href="#brian.experimental.codegen2.resolve" title="brian.experimental.codegen2.resolve"><tt class="xref py py-meth docutils literal"><span class="pre">resolve()</span></tt></a>, can be overridden to modify the namespace,
e.g. adding data.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.Symbol.write">
<tt class="descname">write</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.Symbol.write" title="Permalink to this definition">¶</a></dt>
<dd><p>The string that should be used when this symbol is written, by default
just the symbol name.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.RuntimeSymbol">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">RuntimeSymbol</tt><big>(</big><em>name</em>, <em>language</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.RuntimeSymbol" title="Permalink to this definition">¶</a></dt>
<dd><p>This Symbol is guaranteed by the context to be inserted into the namespace
at runtime and can be used without modification to the name, for example
<tt class="docutils literal"><span class="pre">t</span></tt> or <tt class="docutils literal"><span class="pre">dt</span></tt>.</p>
<dl class="method">
<dt id="brian.experimental.codegen2.RuntimeSymbol.supported">
<tt class="descname">supported</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.RuntimeSymbol.supported" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.ArraySymbol">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">ArraySymbol</tt><big>(</big><em>arr</em>, <em>name</em>, <em>language</em>, <em>index=None</em>, <em>array_name=None</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.ArraySymbol" title="Permalink to this definition">¶</a></dt>
<dd><p>This symbol is used to specify a value taken from an array.</p>
<p>Schematically: <tt class="docutils literal"><span class="pre">name</span> <span class="pre">=</span> <span class="pre">arr[index]</span></tt>.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">arr</span></tt> (numpy array)</dt>
<dd>The numpy array which the values will be taken from.</dd>
<dt><tt class="docutils literal"><span class="pre">name</span></tt>, <tt class="docutils literal"><span class="pre">language</span></tt></dt>
<dd>The name of the symbol and language.</dd>
<dt><tt class="docutils literal"><span class="pre">index</span></tt></dt>
<dd>The index name, by default <tt class="docutils literal"><span class="pre">'_index_'+name</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">array_name</span></tt></dt>
<dd>The name of the array, by default <tt class="docutils literal"><span class="pre">'_arr_'+name</span></tt>.</dd>
</dl>
<p>Introduces a read-dependency on <tt class="docutils literal"><span class="pre">index</span></tt> and <tt class="docutils literal"><span class="pre">array_name</span></tt>.</p>
<dl class="method">
<dt id="brian.experimental.codegen2.ArraySymbol.dependencies">
<tt class="descname">dependencies</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.ArraySymbol.dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-dependency on index.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.ArraySymbol.load">
<tt class="descname">load</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.ArraySymbol.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Method generated by <a class="reference internal" href="#brian.experimental.codegen2.language_invariant_symbol_method" title="brian.experimental.codegen2.language_invariant_symbol_method"><tt class="xref py py-func docutils literal"><span class="pre">language_invariant_symbol_method()</span></tt></a>.</p>
<p>Languages and methods follow:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">python</span></tt></dt>
<dd><a class="reference internal" href="#brian.experimental.codegen2.ArraySymbol.load_python" title="brian.experimental.codegen2.ArraySymbol.load_python"><tt class="xref py py-meth docutils literal"><span class="pre">load_python()</span></tt></a></dd>
<dt><tt class="docutils literal"><span class="pre">gpu</span></tt></dt>
<dd><a class="reference internal" href="#brian.experimental.codegen2.ArraySymbol.load_c" title="brian.experimental.codegen2.ArraySymbol.load_c"><tt class="xref py py-meth docutils literal"><span class="pre">load_c()</span></tt></a></dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd><a class="reference internal" href="#brian.experimental.codegen2.ArraySymbol.load_c" title="brian.experimental.codegen2.ArraySymbol.load_c"><tt class="xref py py-meth docutils literal"><span class="pre">load_c()</span></tt></a></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.ArraySymbol.load_c">
<tt class="descname">load_c</tt><big>(</big><em>read</em>, <em>write</em>, <em>vectorisable</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.ArraySymbol.load_c" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses <a class="reference internal" href="#brian.experimental.codegen2.CDefineFromArray" title="brian.experimental.codegen2.CDefineFromArray"><tt class="xref py py-class docutils literal"><span class="pre">CDefineFromArray</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.ArraySymbol.load_python">
<tt class="descname">load_python</tt><big>(</big><em>read</em>, <em>write</em>, <em>vectorisable</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.ArraySymbol.load_python" title="Permalink to this definition">¶</a></dt>
<dd><p>If <tt class="docutils literal"><span class="pre">read</span></tt> is false, does nothing. Otherwise, returns a
<a class="reference internal" href="#brian.experimental.codegen2.CodeStatement" title="brian.experimental.codegen2.CodeStatement"><tt class="xref py py-class docutils literal"><span class="pre">CodeStatement</span></tt></a> of the form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">name</span> <span class="o">=</span> <span class="n">array_name</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="brian.experimental.codegen2.ArraySymbol.supported_languages">
<tt class="descname">supported_languages</tt><em class="property"> = ['python', 'c', 'gpu']</em><a class="headerlink" href="#brian.experimental.codegen2.ArraySymbol.supported_languages" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.ArraySymbol.update_namespace">
<tt class="descname">update_namespace</tt><big>(</big><em>read</em>, <em>write</em>, <em>vectorisable</em>, <em>namespace</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.ArraySymbol.update_namespace" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds pair <tt class="docutils literal"><span class="pre">(array_name,</span> <span class="pre">arr)</span></tt> to namespace.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.ArraySymbol.write">
<tt class="descname">write</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.ArraySymbol.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Method generated by <a class="reference internal" href="#brian.experimental.codegen2.language_invariant_symbol_method" title="brian.experimental.codegen2.language_invariant_symbol_method"><tt class="xref py py-func docutils literal"><span class="pre">language_invariant_symbol_method()</span></tt></a>.</p>
<p>Languages and methods follow:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">python</span></tt></dt>
<dd><a class="reference internal" href="#brian.experimental.codegen2.ArraySymbol.write_python" title="brian.experimental.codegen2.ArraySymbol.write_python"><tt class="xref py py-meth docutils literal"><span class="pre">write_python()</span></tt></a></dd>
<dt><tt class="docutils literal"><span class="pre">gpu</span></tt></dt>
<dd><a class="reference internal" href="#brian.experimental.codegen2.ArraySymbol.write_c" title="brian.experimental.codegen2.ArraySymbol.write_c"><tt class="xref py py-meth docutils literal"><span class="pre">write_c()</span></tt></a></dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd><a class="reference internal" href="#brian.experimental.codegen2.ArraySymbol.write_c" title="brian.experimental.codegen2.ArraySymbol.write_c"><tt class="xref py py-meth docutils literal"><span class="pre">write_c()</span></tt></a></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.ArraySymbol.write_c">
<tt class="descname">write_c</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.ArraySymbol.write_c" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.ArraySymbol.write_python">
<tt class="descname">write_python</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.ArraySymbol.write_python" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">array_name[index]</span></tt>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.NeuronGroupStateVariableSymbol">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">NeuronGroupStateVariableSymbol</tt><big>(</big><em>group</em>, <em>varname</em>, <em>name</em>, <em>language</em>, <em>index=None</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.NeuronGroupStateVariableSymbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Symbol for a state variable.</p>
<p>Wraps <a class="reference internal" href="#brian.experimental.codegen2.ArraySymbol" title="brian.experimental.codegen2.ArraySymbol"><tt class="xref py py-class docutils literal"><span class="pre">ArraySymbol</span></tt></a>.</p>
<p>Arguments:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">name</span></tt>, <tt class="docutils literal"><span class="pre">language</span></tt></dt>
<dd>Symbol name and language.</dd>
<dt><tt class="docutils literal"><span class="pre">group</span></tt></dt>
<dd>The <tt class="xref py py-class docutils literal"><span class="pre">NeuronGroup</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">varname</span></tt></dt>
<dd>The state variable name in the group.</dd>
<dt><tt class="docutils literal"><span class="pre">index</span></tt></dt>
<dd>An index name (or use default of <a class="reference internal" href="#brian.experimental.codegen2.ArraySymbol" title="brian.experimental.codegen2.ArraySymbol"><tt class="xref py py-class docutils literal"><span class="pre">ArraySymbol</span></tt></a>).</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.SliceIndex">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">SliceIndex</tt><big>(</big><em>name</em>, <em>start</em>, <em>end</em>, <em>language</em>, <em>all=False</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.SliceIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Multi-valued symbol that ranges over a slice.</p>
<p>Schematically: <tt class="docutils literal"><span class="pre">name</span> <span class="pre">=</span> <span class="pre">slice(start,</span> <span class="pre">end)</span></tt></p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">name</span></tt>, <tt class="docutils literal"><span class="pre">language</span></tt></dt>
<dd>Symbol name and language.</dd>
<dt><tt class="docutils literal"><span class="pre">start</span></tt></dt>
<dd>The initial value, can be an integer or string.</dd>
<dt><tt class="docutils literal"><span class="pre">end</span></tt></dt>
<dd>The final value (not included), can be an integer or string.</dd>
<dt><tt class="docutils literal"><span class="pre">all</span></tt></dt>
<dd>Set to <tt class="docutils literal"><span class="pre">True</span></tt> to indicate that the slice covers the whole range
possible (small optimisation for Python).</dd>
</dl>
<dl class="attribute">
<dt id="brian.experimental.codegen2.SliceIndex.multiple_values">
<tt class="descname">multiple_values</tt><em class="property"> = True</em><a class="headerlink" href="#brian.experimental.codegen2.SliceIndex.multiple_values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.SliceIndex.resolution_requires_loop">
<tt class="descname">resolution_requires_loop</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.SliceIndex.resolution_requires_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> except for Python.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.SliceIndex.resolve">
<tt class="descname">resolve</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.SliceIndex.resolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Method generated by <a class="reference internal" href="#brian.experimental.codegen2.language_invariant_symbol_method" title="brian.experimental.codegen2.language_invariant_symbol_method"><tt class="xref py py-func docutils literal"><span class="pre">language_invariant_symbol_method()</span></tt></a>.</p>
<p>Languages and methods follow:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">python</span></tt></dt>
<dd><a class="reference internal" href="#brian.experimental.codegen2.SliceIndex.resolve_python" title="brian.experimental.codegen2.SliceIndex.resolve_python"><tt class="xref py py-meth docutils literal"><span class="pre">resolve_python()</span></tt></a></dd>
<dt><tt class="docutils literal"><span class="pre">gpu</span></tt></dt>
<dd><a class="reference internal" href="#brian.experimental.codegen2.SliceIndex.resolve_gpu" title="brian.experimental.codegen2.SliceIndex.resolve_gpu"><tt class="xref py py-meth docutils literal"><span class="pre">resolve_gpu()</span></tt></a></dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd><a class="reference internal" href="#brian.experimental.codegen2.SliceIndex.resolve_c" title="brian.experimental.codegen2.SliceIndex.resolve_c"><tt class="xref py py-meth docutils literal"><span class="pre">resolve_c()</span></tt></a></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.SliceIndex.resolve_c">
<tt class="descname">resolve_c</tt><big>(</big><em>read</em>, <em>write</em>, <em>vectorisable</em>, <em>item</em>, <em>namespace</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.SliceIndex.resolve_c" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">item</span></tt> embedded in a C for loop.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.SliceIndex.resolve_gpu">
<tt class="descname">resolve_gpu</tt><big>(</big><em>read</em>, <em>write</em>, <em>vectorisable</em>, <em>item</em>, <em>namespace</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.SliceIndex.resolve_gpu" title="Permalink to this definition">¶</a></dt>
<dd><p>If not <tt class="docutils literal"><span class="pre">vectorisable</span></tt> return <a class="reference internal" href="#brian.experimental.codegen2.SliceIndex.resolve_c" title="brian.experimental.codegen2.SliceIndex.resolve_c"><tt class="xref py py-meth docutils literal"><span class="pre">resolve_c()</span></tt></a>. If <tt class="docutils literal"><span class="pre">vectorisable</span></tt>
we mark it by adding <tt class="docutils literal"><span class="pre">_gpu_vector_index</span> <span class="pre">=</span> <span class="pre">name</span></tt> and
<tt class="docutils literal"><span class="pre">_gpu_vector_slice</span> <span class="pre">=</span> <span class="pre">(start,</span> <span class="pre">end)</span></tt> to the namespace. The GPU code
will handle this later on.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.SliceIndex.resolve_python">
<tt class="descname">resolve_python</tt><big>(</big><em>read</em>, <em>write</em>, <em>vectorisable</em>, <em>item</em>, <em>namespace</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.SliceIndex.resolve_python" title="Permalink to this definition">¶</a></dt>
<dd><p>If <tt class="docutils literal"><span class="pre">vectorisable</span></tt> and <tt class="docutils literal"><span class="pre">all</span></tt> then we simply return <tt class="docutils literal"><span class="pre">item</span></tt> and
add <tt class="docutils literal"><span class="pre">name=slice(None)</span></tt> to the namespace.</p>
<p>If <tt class="docutils literal"><span class="pre">vectorisable</span></tt> and not <tt class="docutils literal"><span class="pre">all</span></tt> then we prepend the following
statement to <tt class="docutils literal"><span class="pre">item</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">name</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
</pre></div>
</div>
<p>If not <tt class="docutils literal"><span class="pre">vectorisable</span></tt> then we add a for loop over
<tt class="docutils literal"><span class="pre">xrange(start,</span> <span class="pre">end)</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="brian.experimental.codegen2.SliceIndex.supported_languages">
<tt class="descname">supported_languages</tt><em class="property"> = ['python', 'c', 'gpu']</em><a class="headerlink" href="#brian.experimental.codegen2.SliceIndex.supported_languages" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="brian.experimental.codegen2.ArrayIndex">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">ArrayIndex</tt><big>(</big><em>name</em>, <em>array_name</em>, <em>language</em>, <em>array_len=None</em>, <em>index_name=None</em>, <em>array_slice=None</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.ArrayIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Multi-valued symbol giving an index that iterates through an array.</p>
<p>Schematically: <tt class="docutils literal"><span class="pre">name</span> <span class="pre">=</span> <span class="pre">array_name[array_slice]</span></tt></p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">name</span></tt>, <tt class="docutils literal"><span class="pre">language</span></tt></dt>
<dd>Symbol name and language.</dd>
<dt><tt class="docutils literal"><span class="pre">array_name</span></tt></dt>
<dd>The name of the array we iterate through.</dd>
<dt><tt class="docutils literal"><span class="pre">array_len</span></tt></dt>
<dd>The length of the array (int or string), by default has value
<tt class="docutils literal"><span class="pre">'_len_'+array_name</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">index_name</span></tt></dt>
<dd>The name of the index into the array, by default has value
<tt class="docutils literal"><span class="pre">'_index_'+array_name</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">array_slice</span></tt></dt>
<dd>A pair <tt class="docutils literal"><span class="pre">(start,</span> <span class="pre">end)</span></tt> giving a slice of the array, if left the whole
array will be used.</dd>
</dl>
<p>Dependencies are collected from those arguments that are used (<tt class="docutils literal"><span class="pre">item</span></tt>,
<tt class="docutils literal"><span class="pre">array_name</span></tt>, <tt class="docutils literal"><span class="pre">array_len</span></tt>, <tt class="docutils literal"><span class="pre">array_slice</span></tt>).</p>
<dl class="attribute">
<dt id="brian.experimental.codegen2.ArrayIndex.multiple_values">
<tt class="descname">multiple_values</tt><em class="property"> = True</em><a class="headerlink" href="#brian.experimental.codegen2.ArrayIndex.multiple_values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.ArrayIndex.resolution_requires_loop">
<tt class="descname">resolution_requires_loop</tt><big>(</big><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.ArrayIndex.resolution_requires_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> except for Python.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.ArrayIndex.resolve">
<tt class="descname">resolve</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.ArrayIndex.resolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Method generated by <a class="reference internal" href="#brian.experimental.codegen2.language_invariant_symbol_method" title="brian.experimental.codegen2.language_invariant_symbol_method"><tt class="xref py py-func docutils literal"><span class="pre">language_invariant_symbol_method()</span></tt></a>.</p>
<p>Languages and methods follow:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">python</span></tt></dt>
<dd><a class="reference internal" href="#brian.experimental.codegen2.ArrayIndex.resolve_python" title="brian.experimental.codegen2.ArrayIndex.resolve_python"><tt class="xref py py-meth docutils literal"><span class="pre">resolve_python()</span></tt></a></dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd><a class="reference internal" href="#brian.experimental.codegen2.ArrayIndex.resolve_c" title="brian.experimental.codegen2.ArrayIndex.resolve_c"><tt class="xref py py-meth docutils literal"><span class="pre">resolve_c()</span></tt></a></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.ArrayIndex.resolve_c">
<tt class="descname">resolve_c</tt><big>(</big><em>read</em>, <em>write</em>, <em>vectorisable</em>, <em>item</em>, <em>namespace</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.ArrayIndex.resolve_c" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a C++ for loop of the form:</p>
<div class="highlight-python"><pre>for(int index_name=start; index_name&lt;end; index_name++)
{
    const int name = array_name[index_name];
    ...
}</pre>
</div>
<p>If defined <tt class="docutils literal"><span class="pre">(start,</span> <span class="pre">end)=array_slice</span></tt> otherwise
<tt class="docutils literal"><span class="pre">(start,</span> <span class="pre">end)=(0,</span> <span class="pre">array_len)</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.ArrayIndex.resolve_gpu">
<tt class="descname">resolve_gpu</tt><big>(</big><em>read</em>, <em>write</em>, <em>vectorisable</em>, <em>item</em>, <em>namespace</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.ArrayIndex.resolve_gpu" title="Permalink to this definition">¶</a></dt>
<dd><p>If not vectorisable, use <a class="reference internal" href="#brian.experimental.codegen2.ArrayIndex.resolve_c" title="brian.experimental.codegen2.ArrayIndex.resolve_c"><tt class="xref py py-meth docutils literal"><span class="pre">resolve_c()</span></tt></a>. If vectorisable, we set
the following in the namespace:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">_gpu_vector_index</span> <span class="o">=</span> <span class="n">index_name</span>
<span class="n">_gpu_vector_slice</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
</pre></div>
</div>
<p>Where <tt class="docutils literal"><span class="pre">start</span></tt> and <tt class="docutils literal"><span class="pre">end</span></tt> are as in <a class="reference internal" href="#brian.experimental.codegen2.ArrayIndex.resolve_c" title="brian.experimental.codegen2.ArrayIndex.resolve_c"><tt class="xref py py-meth docutils literal"><span class="pre">resolve_c()</span></tt></a>. This marks
that we want to vectorise over this index, and the GPU code will handle
this later. Finally, we prepend the item with:</p>
<blockquote>
<div>const int name = array_name[index_name];</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="brian.experimental.codegen2.ArrayIndex.resolve_python">
<tt class="descname">resolve_python</tt><big>(</big><em>read</em>, <em>write</em>, <em>vectorisable</em>, <em>item</em>, <em>namespace</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.ArrayIndex.resolve_python" title="Permalink to this definition">¶</a></dt>
<dd><p>If vectorisable it will prepend one of these two forms to <tt class="docutils literal"><span class="pre">item</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">name</span> <span class="o">=</span> <span class="n">array_name</span>
<span class="n">name</span> <span class="o">=</span> <span class="n">array_name</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
</pre></div>
</div>
<p>(where <tt class="docutils literal"><span class="pre">(start,</span> <span class="pre">end)</span> <span class="pre">=</span> <span class="pre">array_slice</span></tt> if provided).</p>
<p>If not vectorisable, it will return a for loop over either
<tt class="docutils literal"><span class="pre">array_name</span></tt> or <cite>array_name[start:end]`</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="brian.experimental.codegen2.ArrayIndex.supported_languages">
<tt class="descname">supported_languages</tt><em class="property"> = ['python', 'c', 'gpu']</em><a class="headerlink" href="#brian.experimental.codegen2.ArrayIndex.supported_languages" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="brian.experimental.codegen2.language_invariant_symbol_method">
<tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">language_invariant_symbol_method</tt><big>(</big><em>basemethname</em>, <em>langs</em>, <em>fallback=None</em>, <em>doc=None</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.language_invariant_symbol_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to create methods for <a class="reference internal" href="#brian.experimental.codegen2.Symbol" title="brian.experimental.codegen2.Symbol"><tt class="xref py py-class docutils literal"><span class="pre">Symbol</span></tt></a> classes.</p>
<p>Sometimes it is clearer to write a separate method for each language the
<a class="reference internal" href="#brian.experimental.codegen2.Symbol" title="brian.experimental.codegen2.Symbol"><tt class="xref py py-class docutils literal"><span class="pre">Symbol</span></tt></a> supports. This function can generate a method that can take
any language, and calls the desired method. For example, if you had defined
two methods <tt class="docutils literal"><span class="pre">load_python</span></tt> and <tt class="docutils literal"><span class="pre">load_c</span></tt> then you would define the
<tt class="docutils literal"><span class="pre">load</span></tt> method as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">load</span> <span class="o">=</span> <span class="n">language_invariant_symbol_method</span><span class="p">(</span><span class="s">&#39;load&#39;</span><span class="p">,</span>
    <span class="p">{</span><span class="s">&#39;python&#39;</span><span class="p">:</span><span class="n">load_python</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">:</span><span class="n">load_c</span><span class="p">})</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">fallback</span></tt> gives a method to call if no language-specific method was
found. A docstring can be provided to <tt class="docutils literal"><span class="pre">doc</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="brian.experimental.codegen2.get_neuron_group_symbols">
<tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">get_neuron_group_symbols</tt><big>(</big><em>group</em>, <em>language</em>, <em>index='_neuron_index'</em>, <em>prefix=''</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.get_neuron_group_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dict of <tt class="xref py py-class docutils literal"><span class="pre">NeuronGroupStateVariable</span></tt> from a group.</p>
<p>Arguments:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">group</span></tt></dt>
<dd>The group to extract symbols from.</dd>
<dt><tt class="docutils literal"><span class="pre">language</span></tt></dt>
<dd>The language to use.</dd>
<dt><tt class="docutils literal"><span class="pre">index</span></tt></dt>
<dd>The name of the neuron index, by default <tt class="docutils literal"><span class="pre">_neuron_index</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">prefix</span></tt></dt>
<dd>An optional prefix to add to each symbol.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="id9">
<h3>threshold<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="brian.experimental.codegen2.CodeGenThreshold">
<em class="property">class </em><tt class="descclassname">brian.experimental.codegen2.</tt><tt class="descname">CodeGenThreshold</tt><big>(</big><em>group</em>, <em>inputcode</em>, <em>language</em>, <em>level=0</em><big>)</big><a class="headerlink" href="#brian.experimental.codegen2.CodeGenThreshold" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/brian-logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Code generation</a><ul>
<li><a class="reference internal" href="#overview">Overview</a><ul>
<li><a class="reference internal" href="#using-numerical-integration-generation">Using numerical integration generation</a></li>
<li><a class="reference internal" href="#using-the-code-generation-package">Using the code generation package</a></li>
<li><a class="reference internal" href="#structure-of-the-package">Structure of the package</a></li>
</ul>
</li>
<li><a class="reference internal" href="#resolution-process">Resolution process</a><ul>
<li><a class="reference internal" href="#example">Example</a></li>
<li><a class="reference internal" href="#resolve"><tt class="docutils literal"><span class="pre">resolve()</span></tt></a></li>
<li><a class="reference internal" href="#convert-to"><tt class="docutils literal"><span class="pre">convert_to()</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#code-generation-in-brian">Code generation in Brian</a><ul>
<li><a class="reference internal" href="#numerical-integration">Numerical integration</a></li>
<li><a class="reference internal" href="#synaptic-propagation">Synaptic propagation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#gpu">GPU</a></li>
<li><a class="reference internal" href="#extending-code-generation">Extending code generation</a></li>
<li><a class="reference internal" href="#inheritance-diagrams">Inheritance diagrams</a><ul>
<li><a class="reference internal" href="#languages">Languages</a></li>
<li><a class="reference internal" href="#code-objects">Code objects</a></li>
<li><a class="reference internal" href="#code-items">Code items</a></li>
<li><a class="reference internal" href="#equations">Equations</a></li>
<li><a class="reference internal" href="#symbols">Symbols</a></li>
<li><a class="reference internal" href="#resolution-and-code-output">Resolution and code output</a></li>
<li><a class="reference internal" href="#integration">Integration</a></li>
<li><a class="reference internal" href="#id1">GPU</a></li>
<li><a class="reference internal" href="#brian-objects">Brian objects</a><ul>
<li><a class="reference internal" href="#connection">Connection</a></li>
<li><a class="reference internal" href="#reset">Reset</a></li>
<li><a class="reference internal" href="#state-updater">State updater</a></li>
<li><a class="reference internal" href="#threshold">Threshold</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#reference">Reference</a><ul>
<li><a class="reference internal" href="#blocks">blocks</a></li>
<li><a class="reference internal" href="#codeitems">codeitems</a></li>
<li><a class="reference internal" href="#codeobject">codeobject</a></li>
<li><a class="reference internal" href="#id2">connection</a></li>
<li><a class="reference internal" href="#dependencies">dependencies</a></li>
<li><a class="reference internal" href="#id3">equations</a></li>
<li><a class="reference internal" href="#expressions">expressions</a></li>
<li><a class="reference internal" href="#formatting">formatting</a></li>
<li><a class="reference internal" href="#id4">gpu</a></li>
<li><a class="reference internal" href="#id5">integration</a></li>
<li><a class="reference internal" href="#id6">languages</a></li>
<li><a class="reference internal" href="#makeintegrator">makeintegrator</a></li>
<li><a class="reference internal" href="#id7">reset</a></li>
<li><a class="reference internal" href="#resolution">resolution</a></li>
<li><a class="reference internal" href="#statements">statements</a></li>
<li><a class="reference internal" href="#stateupdater">stateupdater</a></li>
<li><a class="reference internal" href="#id8">symbols</a></li>
<li><a class="reference internal" href="#id9">threshold</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="developer-equations.html"
                        title="previous chapter">Equations</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="developer-packagestructure.html"
                        title="next chapter">Brian package structure</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/developer-codegen.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="developer-packagestructure.html" title="Brian package structure"
             >next</a> |</li>
        <li class="right" >
          <a href="developer-equations.html" title="Equations"
             >previous</a> |</li>
        <li><a href="index.html">Brian 1.4.1 documentation</a> &raquo;</li>
          <li><a href="developer.html" >Developer&#8217;s guide</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008, Romain Brette, Dan Goodman.
      Last updated on May 01, 2013.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>